Automatically generated by Mendeley Desktop 1.19.2
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@inproceedings{Glistvain2010,
abstract = {Most resource limited embedded systems are programmed using super-loop architecture. Although programs written for super-loop architecture are hard to debug and maintain, however it requires much less memory which makes it suitable for resource limited devices. In this paper, we propose an operating system ¿Romantiki¿ that combines the resource efficiency of super-loop architecture while featuring traditional multitasking coding style which makes it easy to develop and maintain complex projects for. We also compare the speed and memory requirements for Romantiki with a commonly used OS for embedded devices (FreeRTOS).},
author = {Glistvain, R. and Aboelaze, M.},
booktitle = {Informatics and Systems (INFOS), 2010 The 7th International Conference on},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Glistvain, Aboelaze - 2010 - Romantiki OS - A single stack multitasking operating system for resource limited embedded devices.pdf:pdf},
isbn = {978-1-4244-5828-8},
pages = {1--8},
title = {{Romantiki OS - A single stack multitasking operating system for resource limited embedded devices}},
url = {https://ieeexplore.ieee.org/document/5461735},
year = {2010}
}
@inbook{St-Amour2010,
abstract = {Due to their tight memory constraints, small microcontroller based embedded systems have traditionally been implemented using low-level languages. This paper shows that the Scheme programming language can also be used for such applications, with less than 7 kB of total memory. We present PICOBIT, a very compact implementation of Scheme suitable for memory constrained embedded systems. To achieve a compact system we have tackled the space issue in three ways: the design of a Scheme compiler generating compact bytecode, a small virtual machine, and an optimizing C compiler suited to the compilation of the virtual machine.},
address = {Berlin, Heidelberg},
author = {St-Amour, Vincent and Feeley, Marc},
booktitle = {Implementation and Application of Functional Languages. IFL 2009. Lecture Notes in Computer Science, vol 6041.},
doi = {10.1007/978-3-642-16478-1_1},
editor = {Moraz{\'{a}}n, Marco T and Scholz, Sven-Bodo},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/St-Amour, Feeley - 2010 - PICOBIT A compact scheme system for microcontrollers.pdf:pdf},
isbn = {978-3-642-16478-1},
keywords = {SMS1},
mendeley-tags = {SMS1},
pages = {1--17},
publisher = {Springer Berlin Heidelberg},
title = {{PICOBIT: A Compact Scheme System for Microcontrollers}},
url = {https://doi.org/10.1007/978-3-642-16478-1{\_}1},
year = {2010}
}
@inproceedings{Khezri2008,
abstract = {TinyOS is the current state of the art in operating systems for sensor network research. Event- based programming model of TinyOS presents concept of Task to allow postponing processing. For little processing and memory overhead and to avoid race conditions, tasks are non-preemptive. This causes executing long running task reduce system responsiveness. In general two approaches suggested for solving this problem: cooperative and multithreaded multitasking. In this paper we propose a new TinyOS task scheduler to integrate these approaches with new type of tasks. We argue that this approach improves the overall system responsiveness without concerning about data races or complicate programming for developers.},
author = {Khezri, Meysam and Sarram, Mehdi Agha and Adibniya, Fazlollah},
booktitle = {2008 IEEE International Symposium on Parallel and Distributed Processing with Applications},
doi = {10.1109/ISPA.2008.138},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Khezri, Sarram, Adibniya - 2008 - Simplifying Concurrent Programming of Networked Embedded Systems.pdf:pdf},
isbn = {978-0-7695-3471-8},
keywords = {Delay,Embedded system,Job shop scheduling,Multitasking,Operating systems,Programming profession,SMS1,Sensor systems,Sensor systems and applications,Wireless sensor networks,Yarn},
mendeley-tags = {SMS1},
pages = {993--998},
title = {{Simplifying Concurrent Programming of Networked Embedded Systems}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4725258},
year = {2008}
}
@inproceedings{Riedel2010,
abstract = {Wireless Sensing and Radio Identification systems have undergone many innovations during the past years. This has led to short product lifetimes for both software and hardware compared to classical industries. However, especially industries dealing with long-term support of products, e.g. of industrial machinery, and product lifetime of 40+ years may especially profit from an Internet of Things. Motivated by a practical industrial servicing use case this paper shows how we hope to make equally sustainable IoT solutions by employing a model driven software development approach based on code generation for multi-protocol web service gateways.},
author = {Riedel, Till and Fantana, Nicolaie and Genaid, Adrian and Yordanov, Dimitar and Schmidtke, Hedda R and Beigl, Michael},
booktitle = {2010 Internet of Things (IOT)},
doi = {10.1109/IOT.2010.5678449},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Riedel et al. - 2010 - Using Web Service Gateways and Code Generation for Sustainable IoT System Development Motivation Use Case Driven.pdf:pdf},
keywords = {Automata,Internet of things,IoT system,Logic gates,Radiofrequency identification,SMS1,Semantics,Unified modeling language,Web service gateways,Web services,XML,code generation,industrial servicing,internetworking,multi-protocol,program compilers,protocols,radio identification systems,software development approach,software engineering,sustainable development},
mendeley-tags = {SMS1},
month = {nov},
pages = {1--8},
title = {{Using web service gateways and code generation for sustainable IoT system development}},
year = {2010}
}
@article{Madsen2017,
author = {Madsen, Magnus and Lhot{\'{a}}k, Ondřej and Tip, Frank},
doi = {10.1145/3133910},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Madsen, Lhot{\'{a}}k, Tip - 2017 - A model for reasoning about JavaScript promises.pdf:pdf},
issn = {24751421},
journal = {Proceedings of the ACM on Programming Languages},
keywords = {EcmaScript 6,Formal Semantics,JavaScript,Promise Graph,Promises,callback hell},
mendeley-tags = {callback hell},
number = {OOPSLA},
title = {{A model for reasoning about JavaScript promises}},
url = {http://dl.acm.org/citation.cfm?doid=3152284.3133910},
volume = {1},
year = {2017}
}
@misc{Duff88,
abstract = {Reproduction of 1984 netnews note},
author = {Duff, Tom},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Duff - 1988 - Duff's Device.txt:txt},
title = {{Duff's Device}},
url = {https://groups.google.com/forum/#!original/comp.lang.c/sWJtHn6sVps/ESTEdYEpeLsJ},
urldate = {2017-06-19},
year = {1988}
}
@article{Brereton2007,
abstract = {A consequence of the growing number of empirical studies in software engineering is the need to adopt systematic approaches to assessing and aggregating research outcomes in order to provide a balanced and objective summary of research evidence for a particular topic. The paper reports experiences with applying one such approach, the practice of systematic literature review, to the published studies relevant to topics within the software engineering domain. The systematic literature review process is summarised, a number of reviews being undertaken by the authors and others are described and some lessons about the applicability of this practice to software engineering are extracted. The basic systematic literature review process seems appropriate to software engineering and the preparation and validation of a review protocol in advance of a review activity is especially valuable. The paper highlights areas where some adaptation of the process to accommodate the domain-specific characteristics of software engineering is needed as well as areas where improvements to current software engineering infrastructure and practices would enhance its applicability. In particular, infrastructure support provided by software engineering indexing databases is inadequate. Also, the quality of abstracts is poor; it is usually not possible to judge the relevance of a study from a review of the abstract alone. ?? 2006 Elsevier Inc. All rights reserved.},
author = {Brereton, Pearl and Kitchenham, Barbara A. and Budgen, David and Turner, Mark and Khalil, Mohamed},
doi = {10.1016/j.jss.2006.07.009},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Brereton et al. - 2007 - Lessons from applying the systematic literature review process within the software engineering domain.pdf:pdf},
isbn = {0164-1212},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Empirical software engineering,Systematic literature review},
number = {4},
pages = {571--583},
publisher = {Elsevier Inc.},
title = {{Lessons from applying the systematic literature review process within the software engineering domain}},
url = {http://dx.doi.org/10.1016/j.jss.2006.07.009 http://www.sciencedirect.com/science/article/pii/S016412120600197X},
volume = {80},
year = {2007}
}
@misc{Haller2016,
abstract = {This is a proposal to add constructs that simplify asynchronous and concurrent programming in Scala. The main constructs, async and await, are inspired by similar constructs introduced in C{\#} 5.0. The main purpose of async/await is to make it possible to express efficient asynchronous code in a familiar direct style (where suspending operations look as if they were blocking). As a result, non-blocking code using Scala's futures API [1] can be expressed without using higher-order functions, such as map and flatMap, or low-level callbacks.},
author = {Haller, Philipp and Zaugg, Jason},
keywords = {async,asyncawait,await,canonical,scala},
mendeley-tags = {async,asyncawait,await,canonical,scala},
title = {{SIP-22 - Async - Scala Documentation}},
url = {http://docs.scala-lang.org/sips/pending/async.html},
urldate = {2017-09-22},
year = {2016}
}
@unpublished{Riegel2015,
abstract = {I have argued in the past that there are commonalities between the different coroutine proposals and that there are opportunities for a unified proposal. This paper is meant to provide more detail about this. So far, the proposals have been presented as separate vertical solutions, and it has been claimed that there is no substantial common ground between them. However, I believe we should be looking for commonalities, or we will both make future extensions of the features presented in these proposals harder and will make all of them harder to learn for programmers. To me, the design of coroutines and resumable functions is not just in the space of programming interfaces. A large part of it is also at the level of the abstract machine: In particular, how we deal with concurrency beyond std::thread? While it's easy for programmers to use std::thread, they often don't need a full-featured operating system thread nor would want one because of additional, unnecessary overhead that might be attached to it; a thread of execution from a thread pool, or something like a coroutine would often be sufficient and better. I believe there is consensus in SG1 that we need more kinds of threads of execution beyond those spawned by std::thread (see, for example, the parallelism TS or P0072R0). The main points I'm arguing for in this paper are: • Executing coroutines, generators, etc. should be understood as representing threads of execution, with certain execution properties. Note that I did not say that they should be OS threads or similar to what std::thread spawns. • Resumable functions enable a certain implementation of threads of execution, in particular how the call stack is implemented. The so-called stackful coroutines use a more traditional stack implementation. • The compiler can bridge the gap between those two stack implementations un-der certain conditions by providing the impression of a stackful implementation (e.g., calling through normal non-resumable functions) but generating code that is using resumable functions internally. The Transactional Memory TS is a prece-dent for very similar compiler support, showing that it can be both specified and implemented 1 . In this paper I will not discuss interfaces of programming abstractions. Personally, I am more concerned about the design at the conceptual level than about details of a particular interface; my focus is on the internals, both design-wise and how it affects implementations or enables certain ones.},
author = {Riegel, Torvald},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Riegel - 2015 - P0073R0 - On unifying the coroutines and resumable functions proposals.pdf:pdf},
keywords = {ISOCPP},
mendeley-tags = {ISOCPP},
title = {{P0073R0 - On unifying the coroutines and resumable functions proposals}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0073r0.pdf},
year = {2015}
}
@misc{Skerrett2017,
abstract = {For the last 3 years we have been tracking the trends of the IoT developer community through the IoT Developer Survey [2015] [2016]. Today, we released the third edition of the IoT Developer Survey 2017. As in previous years, the report provides some interesting insights into what IoT developers are thinking and using to build IoT solutions. Below are some of the key trends we identified in the results. The survey is the results of a collaboration between the Eclipse IoT Working Group, IEEE, Agile-IoT EU and the IoT Council. Each partner promoted the survey to their respective communities. A total of 713 individuals participated in the survey. The complete report is available for everyone and we also make available the detailed data [xls, odf].},
author = {Skerrett, Ian},
keywords = {RTOS},
mendeley-tags = {RTOS},
title = {{IoT Developer Trends 2017 Edition}},
url = {https://ianskerrett.wordpress.com/2017/04/19/iot-developer-trends-2017-edition/},
urldate = {2017-05-12},
year = {2017}
}
@inproceedings{Paisley2006,
abstract = {The current practice of physical science research has yielded a continuously growing demand for interconnection network bandwidth to support the sharing of large datasets. Academic research networks and internet service providers have provisioned their networks to handle this type of load, which generates prolonged, high-volume traffic between nodes on the network. Maintenance of QoS for all network users demands that the onset of these (Grid bulk) transfers be detected to enable them to be reengineered through resources specifically provisioned to handle this type of traffic. This paper describes a real-time detector that operates at full-line-rate on Gb/s links, operates at high connection rates, and can track the use of ephemeral or non-standard ports.},
author = {Paisley, Jonathan and Sventek, Joseph},
booktitle = {2006 IEEE/IFIP Network Operations and Management Symposium NOMS 2006},
doi = {10.1109/NOMS.2006.1687539},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Paisley, Sventek - 2006 - Real-time Detection of Grid Bulk Transfer Traffic.pdf:pdf},
keywords = {Bandwidth,Data mining,Detectors,Distributed computing,Geophysics computing,Internet,Internet service providers,LVL4,Multiprotocol label switching,Protocols,Protothreads,QoS,Quality of service,Routing,Telecommunication traffic,grid bulk transfer traffic,interconnection network bandwidth,quality of service,real-time detection,telecommunication traffic},
mendeley-tags = {LVL4,Protothreads},
pages = {66--72},
title = {{Real-time Detection of Grid Bulk Transfer Traffic}},
url = {http://eprints.gla.ac.uk/3671/},
year = {2006}
}
@misc{Mittelette2015,
abstract = {We continue to work on resumable functions, here it is a brief update on coroutines status in VS 2015 Update 1. See the Visual Studio 2015 Update1 post here.},
author = {Mittelette, Eric},
title = {{Coroutines in Visual Studio 2015 – Update 1 - Visual C++ Team Blog}},
url = {https://blogs.msdn.microsoft.com/vcblog/2015/11/30/coroutines-in-visual-studio-2015-update-1/},
urldate = {2018-02-04},
year = {2015}
}
@misc{George2014a,
abstract = {MicroPython is a lean and efficient implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimised to run on microcontrollers and in constrained environments.},
author = {George, Damien},
keywords = {Micropython},
mendeley-tags = {Micropython},
title = {{MicroPython - Python for microcontrollers}},
url = {http://micropython.org/},
urldate = {2017-07-31},
year = {2014}
}
@article{Bergel2011,
abstract = {Wireless sensor networks necessitate a programming model different from those used to develop desktop applications. Typically, resources in terms of power and memory are constrained. C is the most common programming language used to develop applications on very small embedded sensor devices. We claim that C does not provide efficient mechanisms to address the implicit asynchronous nature of sensor sampling. C applications for these devices suffer from a disruption in their control flow. In this paper, we present FlowTalk, a new object-oriented programming language aimed at making software development for wireless embedded sensor devices easier. FlowTalk is an object-oriented programming language in which dynamicity (e.g., object creation) has been traded for a reduction in memory consumption. The event model that traditionally comes from using sensors is adapted in FlowTalk with controlled disruption, a light-weight continuation mechanism. The essence of our model is to turn asynchronous long-latency operations into synchronous and blocking method calls. FlowTalk is built for TinyOS and can be used to develop applications that can fit in 4 KB of memory for a large number of wireless sensor devices.},
author = {Bergel, Alexandre and Harrison, William and Cahill, Vinny and Clarke, Siobh{\'{a}}n},
doi = {10.1109/TSE.2010.66},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Bergel et al. - 2011 - FlowTalk Language Support for Long-Latency Operations in Embedded Devices.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Embedded systems,SMS1,object-based programming},
mendeley-tags = {SMS1},
number = {4},
pages = {526--543},
title = {{FlowTalk: Language Support for Long-Latency Operations in Embedded Devices}},
volume = {37},
year = {2011}
}
@article{Syme2011,
abstract = {We describe the asynchronous programming model in F{\#}, and its applications to reactive, parallel and concurrentSyme, D., Petricek, T., {\&} Lomov, D. (2011). The F{\#} asynchronous programming model. In Practical Aspects of Declarative Languages: 13th International Symposium (Vol. 6539 LNCS, pp. 175–189). https://doi.org/10.1007/978-3-642-18378-2{\_}15 programming. The key feature combines a core language with a non-blocking modality to author lightweight asynchronous tasks, where the modality has control flow constructs that are syntactically a superset of the core language and are given an asynchronous semantic interpretation. This allows smooth transitions between synchronous and asynchronous code and eliminates callback-style treatments of inversion of control, without disturbing the foundation of CPU-intensive programming that allows F{\#} to interoperate smoothly and compile efficiently. An adapted version of this approach has recently been announced for a future version of C{\#}.},
author = {Syme, Don and Petricek, Tomas and Lomov, Dmitry},
doi = {10.1007/978-3-642-18378-2_15},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Syme, Petricek, Lomov - 2011 - The Fsharp asynchronous programming model.pdf:pdf},
isbn = {9783642183775},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {F{\#},async,asyncawait,await},
mendeley-tags = {F{\#},async,asyncawait,await},
pages = {175--189},
title = {{The Fsharp asynchronous programming model}},
volume = {6539 LNCS},
year = {2011}
}
@misc{Microsoft2018,
abstract = {This article lists the download links for the latest versions of Microsoft Visual C++.},
author = {{Microsoft Corporation}},
keywords = {C++,MSVC},
mendeley-tags = {C++,MSVC},
title = {{The latest supported Visual C++ downloads}},
url = {https://support.microsoft.com/en-au/help/2977003/the-latest-supported-visual-c-downloads},
urldate = {2018-08-14},
year = {2018}
}
@inproceedings{Fritzsche2010,
abstract = {Real-time systems mainly consist of time or event-triggered tasks that must satisfy deadline-constraints and other limitations to the execution time. Scheduling of them is a common problem especially if no operating system can be used because of limited resources like code-size and CPU power. Previous approaches deal with multi-frame models to split tasks into smaller subtask that may be arranged at compile-time in a static way to cope with given deadlines. Handling of non-periodic events and context-switching problems demand a more dynamic scheduling. This paper presents an approach of using manually given information for timing constraints in order to rearrange the code to satisfy the deadlines automatically. The presented design is still able to handle events and to force the given functions to cooperate. Supporting hardware for producing timing-events may further help the system to organize the program-flow.},
author = {Fritzsche, Rene and Siemers, Christian},
booktitle = {2010 World Automation Congress},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Fritzsche, Siemers - 2010 - Scheduling of Time Enhanced C (Tec).pdf:pdf},
isbn = {9781424496730},
keywords = {SMS1,application-internal scheduler,forced cooperative design,multi-frame tasks,semi-dynamic scheduling,time-enhanced language},
mendeley-tags = {SMS1},
pages = {1--6},
title = {{Scheduling of Time Enhanced C (Tec)}},
year = {2010}
}
@article{Sicari2015,
abstract = {Internet of Things (IoT) is characterized by heterogeneous technologies, which concur to the provisioning of innovative services in various application domains. In this scenario, the satisfaction of security and privacy requirements plays a fundamental role. Such requirements include data confidentiality and authentication, access control within the IoT network, privacy and trust among users and things, and the enforcement of security and privacy policies. Traditional security countermeasures cannot be directly applied to IoT technologies due to the different standards and communication stacks involved. Moreover, the high number of interconnected devices arises scalability issues; therefore a flexible infrastructure is needed able to deal with security threats in such a dynamic environment. In this survey we present the main research challenges and the existing solutions in the field of IoT security, identifying open issues, and suggesting some hints for future research.},
archivePrefix = {arXiv},
arxivId = {1404.7799},
author = {Sicari, S. and Rizzardi, A. and Grieco, L.A. and Coen-Porisini, A.},
doi = {10.1016/j.comnet.2014.11.008},
eprint = {1404.7799},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Sicari et al. - 2015 - Security, privacy and trust in Internet of Things The road ahead.pdf:pdf},
isbn = {1389-1286},
issn = {13891286},
journal = {Computer Networks},
keywords = {Internet of Things,IoT,Privacy,Review,Security,Survey,Trust},
mendeley-tags = {IoT,Review,Security,Survey},
month = {jan},
pages = {146--164},
pmid = {18926558},
publisher = {Elsevier B.V.},
title = {{Security, privacy and trust in Internet of Things: The road ahead}},
url = {http://dx.doi.org/10.1016/j.comnet.2014.11.008 http://linkinghub.elsevier.com/retrieve/pii/S1389128614003971},
volume = {76},
year = {2015}
}
@article{Hempel2008,
author = {Hempel, Ralph},
chapter = {26},
isbn = {8590379841},
journal = {Lua Programming Gems},
keywords = {Lua},
mendeley-tags = {Lua},
publisher = {Lua.org},
title = {{Porting Lua to a microcontroller}},
year = {2008}
}
@inproceedings{Meijer2010,
address = {New York, New York, USA},
author = {Meijer, Erik},
booktitle = {ACM SIGPLAN Commercial Users of Functional Programming on - CUFP '10},
doi = {10.1145/1900160.1900173},
isbn = {9781450305167},
pages = {1},
publisher = {ACM Press},
title = {{Reactive extensions (Rx): Curing Your Asynchronous Programming Blues}},
url = {http://portal.acm.org/citation.cfm?doid=1900160.1900173},
year = {2010}
}
@unpublished{VanRossum2005,
author = {van Rossum, Guido and Eby, Phillip J.},
institution = {Python.org},
keywords = {Coroutines,Python},
mendeley-tags = {Coroutines,Python},
title = {{PEP 342 -- Coroutines via Enhanced Generators}},
url = {https://www.python.org/dev/peps/pep-0342/},
year = {2005}
}
@inproceedings{Kalebe2017,
author = {Kalebe, Rubem and Girao, Gustavo and Filho, Itamir},
booktitle = {2017 International Conference on Computing Networking and Informatics (ICCNI)},
doi = {10.1109/ICCNI.2017.8123793},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kalebe, Girao, Filho - 2017 - A library for scheduling lightweight threads in Internet of Things microcontrollers.pdf:pdf},
isbn = {978-1-5090-4642-3},
month = {oct},
pages = {1--7},
publisher = {IEEE},
title = {{A library for scheduling lightweight threads in Internet of Things microcontrollers}},
url = {http://ieeexplore.ieee.org/document/8123793/},
year = {2017}
}
@article{Knuth1968,
author = {Knuth, Donald E},
publisher = {Addison Wesley Longman Publishing Co., Inc.},
title = {{The Art of Computer Programming, Vol. 1: Fundamental Algorithms (3rd. ed.)}},
year = {1997}
}
@unpublished{ISO2017,
abstract = {This Technical Specification describes extensions to the C++ Programming Language (Clause 2) that enable definition of coroutines. These extensions include new syntactic forms and modifications to existing language semantics.},
author = {ISO/IEC},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/ISOIEC - 2017 - N4680 Programming Languages - C Extensions for Library Fundamentals.pdf:pdf},
keywords = {Coroutines,ISO},
mendeley-tags = {Coroutines,ISO},
number = {30},
title = {{N4680 Programming Languages - C++ Extensions for Library Fundamentals}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf},
year = {2017}
}
@inproceedings{Okur2014,
address = {New York, New York, USA},
author = {Okur, Semih and Hartveld, David L. and Dig, Danny and van Deursen, Arie},
booktitle = {Proceedings of the 36th International Conference on Software Engineering - ICSE 2014},
doi = {10.1145/2568225.2568309},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Okur et al. - 2014 - A Study and Toolkit for Asynchronous Programming in C{\#}.pdf:pdf},
isbn = {9781450327565},
keywords = {C{\#},LVL1,Program transformation,asynchronous},
mendeley-tags = {LVL1},
pages = {1117--1127},
publisher = {ACM Press},
title = {{A Study and Toolkit for Asynchronous Programming in C{\#}}},
url = {http://dl.acm.org/citation.cfm?doid=2568225.2568309},
year = {2014}
}
@article{Moura2004a,
abstract = {After a period of oblivion, a renewal of interest in coroutines is being observed. However, most current implementations of coroutine mechanisms are restricted, and motivated by particular uses. The convenience of providing true coroutines as a general control abstraction is disregarded. This paper presents and discusses the coroutine facilities provided by the language Lua, a full implementation of the concept of asymmetric coroutines. It also shows that this powerful construct supports easy and succint implementations of useful control behaviors.},
author = {Moura, Ana L{\'{u}}cia De and Rodriguez, Noemi and Ierusalimschy, Roberto},
doi = {10.3217/jucs-010-07-0910},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Moura, Rodriguez, Ierusalimschy - 2004 - Coroutines in Lua.pdf:pdf},
issn = {0958695X},
journal = {Journal of Universal Computer Science},
keywords = {Coroutine,LVL9,Lua,control structures,coroutines,generators,lua language},
mendeley-tags = {Coroutine,LVL9,Lua},
number = {7},
pages = {910--925},
title = {{Coroutines in Lua}},
url = {http://www.jucs.org/jucs{\_}10{\_}7/coroutines{\_}in{\_}lua/de{\_}moura{\_}a{\_}l.pdf},
volume = {10},
year = {2004}
}
@techreport{Goodspeed2014,
abstract = {At Rapperswil in June 2014, Nat Goodspeed and Oliver Kowalke brought to SG1 a proposal to add coroutines to C++i . Niklas Gustafsson brought a proposal to add resumable functions to C++ii. We were directed by SG1 to place these proposals within a single conceptual space so as to unify them to the extent possible. Nat, Oliver, Niklas and Torvald Riegel discussed this conceptual space at length at Rapperswil. Nat and Gor Nishanov pursued the discussion further in Redmond. This paper is an attempt to respond to the committee's request.},
author = {Goodspeed, Nat},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Goodspeed - 2014 - Stackful Coroutines and Stackless Resumable Functions.pdf:pdf},
keywords = {ISOCPP},
mendeley-tags = {ISOCPP},
title = {{Stackful Coroutines and Stackless Resumable Functions}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4232.pdf},
year = {2014}
}
@inproceedings{Gay2003,
abstract = {We present nesC, a programming language for networked embedded systems that represent a new design space for application developers. An example of a networked embedded system is a sensor network, which consists of (potentially) thousands of tiny, low-power "motes," each of which execute concurrent, reactive programs that must operate with severe memory and power constraints.nesC's contribution is to support the special needs of this domain by exposing a programming model that incorporates event-driven execution, a flexible concurrency model, and component-oriented application design. Restrictions on the programming model allow the nesC compiler to perform whole-program analyses, including data-race detection (which improves reliability) and aggressive function inlining (which reduces resource consumption).nesC has been used to implement TinyOS, a small operating system for sensor networks, as well as several significant sensor applications. nesC and TinyOS have been adopted by a large number of sensor network research groups, and our experience and evaluation of the language shows that it is effective at supporting the complex, concurrent programming style demanded by this new class of deeply networked systems.},
address = {New York, New York, USA},
author = {Gay, David and Levis, Philip and von Behren, Robert and Welsh, Matt and Brewer, Eric and Culler, David},
booktitle = {Proceedings of the ACM SIGPLAN 2003 conference on Programming language design and implementation - PLDI '03},
doi = {10.1145/781131.781133},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Gay et al. - 2003 - The nesC Language A Holistic Approach to Networked Embedded Systems.pdf:pdf},
isbn = {1581136625},
issn = {03621340},
keywords = {C,LVL2,TinyOS,components,concurrency,data races,first-order,modules,nesC,programming languages},
mendeley-tags = {LVL2},
pages = {1----11},
publisher = {ACM Press},
title = {{The nesC Language: A Holistic Approach to Networked Embedded Systems}},
url = {http://portal.acm.org/citation.cfm?doid=781131.781133},
year = {2003}
}
@article{Liu2011,
abstract = {SystemC is a widely used electronic system-level (ESL) design language that can be used to model both hardware and software at different stages of system design. There has been a lot of research on behavior synthesis of hardware from SystemC, but relatively little work on synthesizing embedded software for SystemC designs. In this letter, we present an approach to automatic software synthesis from SystemC-based on coroutines instead of the traditional approaches based on real-time operating system (RTOS) threads. Performance evaluation results on some realistic applications show that our approach results in impressive reduction of runtime overheads compared to the thread-based approaches.},
author = {Liu, Weichen and Xu, Jiang and Muppala, Jogesh K. and Zhang, Wei and Wu, Xiaowen and Ye, Yaoyao and Zhang, Wei},
doi = {10.1109/LES.2011.2112634},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Liu et al. - 2011 - Coroutine-Based Synthesis of Efficient Embedded Software From SystemC Models.pdf:pdf},
isbn = {1943-0663 VO - 3},
issn = {19430663},
journal = {IEEE Embedded Systems Letters},
keywords = {Coroutines,LVL0,Performance,Protothreads,SMS1,SystemC,software synthesis},
mendeley-tags = {Coroutines,LVL0,Protothreads,SMS1},
number = {1},
pages = {46--49},
title = {{Coroutine-Based Synthesis of Efficient Embedded Software From SystemC Models}},
volume = {3},
year = {2011}
}
@inbook{Lohmann2012,
abstract = {CiAO is the first operating-system family that has been developed with AOP concepts from the very beginning. By its aspect-aware design and implementation, CiAO reaches excellent configurability, separation of concerns, and low footprints in the resulting systems that outperform leading commercial implementations. CiAO implements the automotive operating-system standard OSEK/AUTOSAR OS and provides configurability of all fundamental system properties by means of AOP.},
address = {Berlin, Heidelberg},
author = {Lohmann, Daniel and Spinczyk, Olaf and Hofer, Wanja and Schr{\"{o}}der-Preikschat, Wolfgang},
booktitle = {Transactions on Aspect-Oriented Software Development IX},
doi = {10.1007/978-3-642-35551-6_5},
editor = {Leavens, Gary T and Chiba, Shigeru and Haupt, Michael and Ostermann, Klaus and Wohlstadter, Eric},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Lohmann et al. - 2012 - The aspect-aware design and implementation of the CiAO operating-system family.pdf:pdf},
isbn = {978-3-642-35551-6},
keywords = {SMS1},
mendeley-tags = {SMS1},
pages = {168--215},
publisher = {Springer},
title = {{The Aspect-Aware Design and Implementation of the CiAO Operating-System Family}},
url = {https://doi.org/10.1007/978-3-642-35551-6{\_}5},
year = {2012}
}
@article{Andalam2014,
abstract = {Safety-critical embedded systems, commonly found in automotive, space, and health-care, are highly reactive and concurrent. Their most important characteristics are that they require both functional and timing correctness. C has been the language of choice for programming such systems. However, C lacks many features that can make the design process of such systems seamless while also maintaining predictability. This paper addresses the need for a C-based design framework for achieving time predictability. To this end, we propose the PRET-C language and the ARPRET architecture. PRET-C offers a small set of extensions to a subset of C to facilitate effective concurrent programming. We present a new synchronous semantics for PRET-C. It guarantees that all PRET-C programs are deterministic, reactive, and provides thread-safe communication via shared memory access. This simplifies considerably the design of safety-critical systems. We also present the architecture of a precision timed machine (PRET) called ARPRET. It offers the ability to design time predictable architectures through simple customizations of soft-core processors. We have designed ARPRET particularly for efficient and predictable execution of PRET-C. We demonstrate through extensive benchmarking that PRET-C based system design excels in comparison to existing C-based paradigms. We also qualitatively compare our approach to the Berkeley-Columbia PRET approach. We have demonstrated that the proposed approach provides an ideal framework for designing and validating safety-critical embedded systems.},
author = {Andalam, Sidharta and Roop, Partha S. and Girault, Alain and Traulsen, Claus},
doi = {10.1109/TC.2013.28},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Andalam et al. - 2014 - A Predictable Framework for Safety-Critical Embedded Systems.pdf:pdf},
isbn = {0018-9340 VO - 63},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {ARPRET,ARPRET architecture,Berkeley-Columbia PRET approach,C language,C-based design framework,Computer architecture,Instruction sets,PRET,PRET-C,PRET-C language,PRET-C programs,Precision Timed C language,Programming,Real-time systems,SMS1,Safety-critical systems,Semantics,Timing,WCET,WCRT,architecture of a precision timed machine,concurrent programming,deterministic programs,embedded systems,lightweight multithreaded language,multi-threading,programming language semantics,reactive programs,safety-critical embedded systems,safety-critical software,shared memory access,shared memory systems,soft-core processors,synchronous languages,synchronous semantics,thread-safe communication,time predictability,time predictable architectures},
mendeley-tags = {SMS1},
number = {7},
pages = {1600--1612},
title = {{A Predictable Framework for Safety-Critical Embedded Systems}},
volume = {63},
year = {2014}
}
@inproceedings{Clark2009,
abstract = {As the power of the integrated processors that control today's instruments continues to climb, instrument vendors will increasingly add features that allow users to utilize the added intelligence by embedding custom applications directly onboard the instrument. For the test, measurement and automation industries, this paradigm is a complement to, among other things, the advent of synthetic instruments that can ldquobe anything you want,rdquo the frequent use of mezzanine type hardware and the rise of the LXI specification in which instrument to instrument messaging allows one instrument to control and communicate with another without the necessity of a host PC. There are various approaches the instrument vendor can take to permit users to develop embedded applications to be run on the instrument processor. Arguably the most advantageous approach, to both the vendor and customer, is to embed a high level scripting language allowing the user to easily develop scripts to perform instrument based operations. The Lua scripting language is a compact, full featured scripting language that is easily portable and seamlessly integrates into embedded designs. Written in pure ISO ANSI-C, the Lua interpreter and Lua libraries have been successfully ported to a large number of platforms, big and small, and with and without advanced operating systems such as Windows and Linux. Lua contains an API for interfacing directly to and from the instrument's embedded firmware and includes a full suite of libraries. Further, Lua is extendable. Thus, in addition to embedding the language interpreter and libraries, the vendor can implement custom libraries and various other custom utilities to increase the flexibility of the system and enhance the capabilities of the user developed scripts. This paper studies the use of Lua in intelligent instrumentation. It discusses features that provide flexibility and power to users embedding applications onboard instruments and it presents some real wo- rld applications of the technology.},
author = {Clark, David L.},
booktitle = {2009 IEEE AUTOTESTCON},
doi = {10.1109/AUTEST.2009.5314042},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Clark - 2009 - Powering intelligent instruments with Lua scripting.pdf:pdf},
isbn = {978-1-4244-4980-4},
issn = {1088-7725},
keywords = {Coroutines,Lua,SMS1},
mendeley-tags = {Coroutines,Lua,SMS1},
month = {sep},
pages = {101--106},
publisher = {IEEE},
title = {{Powering intelligent instruments with Lua scripting}},
url = {http://ieeexplore.ieee.org/document/5314042/},
year = {2009}
}
@article{Schimpf2012b,
abstract = {Protothreads are stackless lightweight threads that provide a mechanism for concurrent programming with very low overhead in any environment that supports an ANSI-C compiler. No processor-specific task switching code is required to implement them. In their published form they are not quite adequate for a priority-based based scheduler and thus are of questionable utility in an embedded system with real-time requirements. This article discusses the protothread library along with modifications and an example priority-based scheduler that may be of some utility in embedded systems environments lacking an RTOS.},
author = {Schimpf, Paul H},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Schimpf - 2012 - Modified Protothreads for Embedded Systems.pdf:pdf},
journal = {Journal of Computing Sciences in Colleges},
keywords = {LVL0,Protothreads,SMS1},
mendeley-tags = {LVL0,Protothreads,SMS1},
number = {1},
pages = {177--184},
title = {{Modified Protothreads for Embedded Systems}},
url = {http://dl.acm.org/citation.cfm?id=2379703.2379738},
volume = {28},
year = {2012}
}
@misc{LLVMProject2018,
author = {{LLVM Project}},
keywords = {C++,LLVM},
mendeley-tags = {C++,LLVM},
title = {{Download LLVM releases}},
url = {http://releases.llvm.org/},
urldate = {2018-08-14},
year = {2018}
}
@inproceedings{Inam2011,
abstract = {This paper presents the implementation of a Hierarchical Scheduling Framework (HSF) on an open source real-time operating system (FreeRTOS) to support the temporal isolation between a number of applications, on a single processor. The goal is to achieve predictable integration and reusability of independently developed components or applications. We present the initial results of the HSF implementation by running it on an AVR 32-bit board EVK1100. The paper addresses the fixed-priority preemptive scheduling at both global and local scheduling levels. It describes the detailed design of HSF with the emphasis of doing minimal changes to the underlying FreeRTOS kernel and keeping its API intact. Finally it provides (and compares) the results for the performance measures of idling and deferrable servers with respect to the overhead of the implementation.},
author = {Inam, R and M{\"{a}}ki-Turja, J and Sj{\"{o}}din, M and Ashjaei, S M H and Afshar, S},
booktitle = {ETFA2011},
doi = {10.1109/ETFA.2011.6059016},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Inam et al. - 2011 - Hierarchical Scheduling Framework Implementation in FreeRTOS.pdf:pdf},
issn = {1946-0740},
keywords = {API,AVR EVK1100,FreeRTOS kernel,Job shop scheduling,Kernel,Processor scheduling,Real time systems,SMS1,Schedules,Servers,application program interfaces,application reusability,fixed-priority preemptive scheduling,fixed-priority scheduling,global scheduling levels,hierarchical scheduling framework,independently developed component reusability,local scheduling levels,object-oriented programming,open source real-time operating system,operating system kernels,predictable integration,public domain software,real-time systems,scheduling,single processor,software reusability,temporal isolation},
mendeley-tags = {SMS1},
month = {sep},
pages = {1--10},
title = {{Support for hierarchical scheduling in FreeRTOS}},
year = {2011}
}
@article{Conway1963,
abstract = {A COBOL compiler design is presented which is compact enough to permit rapid, one-pass compilation of a large sub-set of COBOL on a moderately large computer. Versions of the same compiler for smaller machines require only two work-ing tapes plus a compiler tape. The methods given are largely applicable to the construction of ALGOL compilers.},
address = {New York, NY, USA},
author = {Conway, Melvin E},
doi = {10.1145/366663.366704},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Conway - 1963 - Design of a Separable Transition-diagram Compiler.pdf:pdf},
issn = {0001-0782},
journal = {Commun. ACM},
month = {jul},
number = {7},
pages = {396--408},
publisher = {ACM},
title = {{Design of a Separable Transition-diagram Compiler}},
url = {http://melconway.com/Home/pdf/compiler.pdf http://doi.acm.org/10.1145/366663.366704},
volume = {6},
year = {1963}
}
@misc{Herity2015,
abstract = {The suspicion lingers that C++ is somehow unsuitable for use in small embedded systems. For 8- and 16-bit processors lacking a C++ compiler, that may be a concern, but there are now 32-bit microcontrollers available for under a dollar supported by mature C++ compilers. As this article series will make clear, with the continued improvements in the language most C++ features have no impact on code size or on speed. Others have a small impact that is generally worth paying for. To use C++ effectively in embedded systems, you need to be aware of what is going on at the machine code level, just as in C. Armed with that knowledge, the embedded systems programmer can produce code that is smaller, faster and safer than is possible without C++.},
author = {Herity, Dominic},
booktitle = {Embedded},
title = {{Modern C++ in embedded systems – Part 1: Myth and Reality | Embedded}},
url = {https://www.embedded.com/design/programming-languages-and-tools/4438660/1/Modern-C--in-embedded-systems---Part-1--Myth-and-Reality},
urldate = {2018-01-24},
year = {2015}
}
@inproceedings{Cohen2007b,
abstract = {This paper proposes a concurrency model which integrates the asynchronous and event-driven nature of wireless sensor networks with higher-level abstractions that provide a more familiar programming style for the developer. As a basis for this proposal, we designed and implemented a cooperative multitasking scheduler, based on coroutines, for the TinyOS operating system. We then used this scheduler to implement RPC-like interfaces that capture different communication patterns common in wireless sensor networks. This allows the programmer to work, when appropriate, with a synchronous style, while maintaining an asynchronous model at the message exchange level.},
author = {Cohen, Marcelo and Ponte, Thiago and Rossetto, Silvana and Rodriguez, Noemi},
booktitle = {2007 IEEE International Parallel and Distributed Processing Symposium},
doi = {10.1109/IPDPS.2007.370458},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Cohen et al. - 2007 - Using Coroutines for RPC in Sensor Networks.pdf:pdf},
isbn = {1424409101},
keywords = {Coroutines,LVL0,SMS1,TinyOS},
mendeley-tags = {Coroutines,LVL0,SMS1,TinyOS},
pages = {1--8},
title = {{Using Coroutines for RPC in Sensor Networks}},
year = {2007}
}
@inproceedings{Jahier2016,
abstract = {Debugging reactive programs requires to provide a lot of inputs -- at each reaction step. Moreover, because a reactive system reacts to an environment it tries to control, providing realistic inputs can be hard. The same considerations apply for automatic testing. This work take advantage on previous work on automated testing of reactive programs that close this feedback loop. This article demonstrates how to implement opportunistically such a debugging commands interpreter by taking advantage of an existing (ocaml) toplevel Read-Eval-Print Loop (REPL). Then it shows how a small kernel is enough to build a full-featured debugger with little effort. The given examples provide a tutorial for end-users that wish to write their own debugging primitives, fitting to their needs, or to tune existing ones. An orthogonal contribution of this article is to present an efficient way to implement the debugger coroutining using continuations. The Reactive programs DeBuGger (RDBG) prototype aims at being versatile and general enough to be able to deal with any reactive languages. We have experimented it on 2 synchronous programming: Lustre and Lutin.},
address = {New York, NY, USA},
author = {Jahier, Erwan},
booktitle = {Proceedings of the 19th International Workshop on Software and Compilers for Embedded Systems},
doi = {10.1145/2906363.2906372},
editor = {Stuijk, Sander},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Jahier - 2016 - RDBG a Reactive Programs Extensible Debugger.pdf:pdf},
isbn = {978-1-4503-4320-6},
keywords = {Code Instrumentation,Compiler,Continuations,Dynamic Analysis,Interpreter,Monitor,Programmable Debuggers,Reactive systems,SMS1,Synchronous languages},
mendeley-tags = {SMS1},
pages = {116--125},
publisher = {ACM},
series = {SCOPES '16},
title = {{RDBG: A Reactive Programs Extensible Debugger}},
url = {http://doi.acm.org/10.1145/2906363.2906372},
year = {2016}
}
@article{Yu2008,
abstract = {Although TinyOS has been regarded as the defacto standard for WSN (Wireless Sensor Network) applications, its simple task scheduling mechanism became a great obstacle to WSN applications. This paper, from two directions (one based on cooperative, the other based on preemptive), presented a variety of scheduling algorithms and their application in TinyOS. And their characters and advantage were discussed as well in terms of energy consuming, tasks executing efficiency. Then a new, integrated and adaptive task scheduling mechanism was pointed out for the future TinyOS task scheduling. This new scheduling mechanism was characterized with features of dynamical adaptability and context-awareness.},
author = {Yu, Min and Xiahou, SiJi and Li, XinYu},
doi = {10.1109/WiCom.2008.960},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Yu, Xiahou, Li - 2008 - A Survey of Studying on Task Scheduling Mechanism for TinyOS.pdf:pdf},
isbn = {9781424421084},
journal = {2008 4th International Conference on Wireless Communications, Networking and Mobile Computing},
keywords = {SMS1,Task scheduling,TinyOS,WSN},
mendeley-tags = {SMS1},
pages = {1--4},
title = {{A Survey of Studying on Task Scheduling Mechanism for TinyOS}},
year = {2008}
}
@inproceedings{Brodu2015,
abstract = {Javascript is the prevalent scripting language for the web. It lets web pages register callbacks to react to user events. A callback is a function to be invoked later with a result currently unavailable. This pattern also proved to respond efficiently to remote requests. Javascript is currently used to implement complete web applications. However, callbacks are ill-suited to arrange a large asynchronous execution flow. Promises are a more adapted alternative. They provide a unified control over both the synchronous and asynchronous execution flows. The next version of Javascript proposes to replace callbacks with Promises. This paper brings the first step toward a compiler to help developers prepare this shift. We present an equivalence between callbacks and Dues. The latter are a simpler specification of Promises developed for the purpose of this demonstration. From this equivalence, we implement a compiler to transform an imbrication of callbacks into a chain of Dues. This equivalence is limited to Node.js-style asynchronous callbacks declared in situ. We evaluate our compiler over 64 npm packages, 9 of them present compatible callbacks and compile successfully. We consider this shift to be a first step toward the merge of concepts from the data-flow programming model into the imperative programming model.},
address = {New York, New York, USA},
author = {Brodu, Etienne and Fr{\'{e}}not, St{\'{e}}phane and Obl{\'{e}}, Fr{\'{e}}d{\'{e}}ric},
booktitle = {Proceedings of the 1st Workshop on All-Web Real-Time Systems - AWeS '15},
doi = {10.1145/2749215.2749216},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Brodu, Fr{\'{e}}not, Obl{\'{e}} - 2015 - Toward Automatic Update from Callbacks to Promises.pdf:pdf},
isbn = {9781450334778},
keywords = {Javascript,LVL1,await,compilation,flow programming,web},
mendeley-tags = {LVL1,await},
pages = {1--8},
publisher = {ACM Press},
title = {{Toward Automatic Update from Callbacks to Promises}},
url = {http://dl.acm.org/citation.cfm?doid=2749215.2749216},
year = {2015}
}
@inbook{Alvira2013,
abstract = {This work presents a computer board designed for autonomous robotic sailboat control. Taking advantage of the current availability of feature-rich processors such as the LPC3130 from NXP and the MC13224v from Freescale Semiconductor used in this work, our design emphasizes low cost and power consumption, as well as small size. At the same time, the system is not excessively specialized; it runs 32-bit Linux and has network capability via Ethernet,WiFi, cellular or Bluetooth USB sticks. The computing system presented in this work is applicable to a variety of robotic sailboat applications, including making a 0.5 m Graupner Micro Magic fully autonomous without relying on a shore-side base station for computation.},
address = {Berlin, Heidelberg},
author = {Alvira, Mariano and Barton, Taylor},
booktitle = {Robotic Sailing 2012},
doi = {10.1007/978-3-642-33084-1_10},
editor = {Sauz{\'{e}}, Colin and Finnis, James},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Alvira, Barton - 2012 - Small and Inexpensive Single-Board Computer for Autonomous Sailboat Control.pdf:pdf},
isbn = {978-3-642-33084-1},
keywords = {SMS1},
mendeley-tags = {SMS1},
pages = {105--116},
publisher = {Springer, Berlin, Heidelberg},
title = {{Small and Inexpensive Single-Board Computer for Autonomous Sailboat Control}},
url = {https://doi.org/10.1007/978-3-642-33084-1{\_}10},
year = {2013}
}
@inproceedings{Kugler2013,
abstract = {Wearable sensors are widely used for data collection in many applications. Ssensor nodes have also been applied for real-time applications, e.g. for ECG analysis or activity and fall detection. Processing of the sensor data is either done on an external device or on the node itself. While on-node processing reduces data rate and increases battery life, development and testing can be time-consuming. To allow faster implementation of such algorithms, we propose a simulation framework for the Shimmer platform using the Cooja simulator, MSPSim and the Contiki operating system. We provide the simulator and example applications compatible with the ShimmerConnect protocol, allowing streaming of raw and pre-processed sensor data to MATLAB, LabView and Android. Additionally, a simple activity and fall detection algorithm was implemented on the sensor node and evaluated using both the simulator and real hardware. In the future this will allow rapid development and testing of on-node pre-processing algorithms. {\textcopyright} 2013 IEEE.},
author = {Kugler, Patrick and Nordhus, Philipp and Eskofier, Bjoern},
booktitle = {2013 IEEE International Conference on Body Sensor Networks},
doi = {10.1109/BSN.2013.6575497},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kugler, Nordhus, Eskofier - 2013 - Shimmer, Cooja and Contiki A new toolset for the simulation of on-node signal processing algorithms.pdf:pdf},
isbn = {9781479903306},
issn = {2376-8894},
keywords = {Bluetooth,Hardware,Operating systems,SMS1,Sensors,Testing,Wireless communication,Wireless sensor networks},
mendeley-tags = {SMS1},
pages = {1--6},
title = {{Shimmer, Cooja and Contiki: A new toolset for the simulation of on-node signal processing algorithms}},
year = {2013}
}
@inproceedings{Jaaskelainen2008,
abstract = {Multithreading is an important software modularization technique. However, it can incur substantial overheads, especially in processors where the amount of architecturally visible state is large. We propose an implementation technique for co-operative multithreading, where context switches occur in places that minimize the amount of state that needs to be saved. The subset of processor state saved during each context switch is based on where the switch occurs.We have validated the approach by an empirical study of resource usage in basic blocks, and by implementing the co-operative threading in our compiler. Performance figures are given for an MP3 player utilizing the threading implementation.},
author = {J{\"{a}}{\"{a}}skel{\"{a}}inen, Pekka and Kellom{\"{a}}ki, Pertti and Takala, Jarmo and Kultala, Heikki and Lepist{\"{o}}, Mikael},
booktitle = {2008 IEEE/IFIP International Conference on Embedded and Ubiquitous Computing},
doi = {10.1109/EUC.2008.181},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/J{\"{a}}{\"{a}}skel{\"{a}}inen et al. - 2008 - Reducing Context Switch Overhead with Compiler-Assisted Threading.pdf:pdf},
isbn = {9780769534923},
keywords = {SMS1},
mendeley-tags = {SMS1},
pages = {461--466},
title = {{Reducing Context Switch Overhead with Compiler-Assisted Threading}},
volume = {2},
year = {2008}
}
@inproceedings{Evers2007,
abstract = {The supply chain management business can benefit greatly from automation, as recent developments with RFID technology shows. The use of Wireless Sensor Network technology promises to bring the next leap in efficiency and quality of service. However, current WSN system software does not yet provide the required functionality, flexibility and safety. This paper discusses a scenario showing how WSN technology can benefit supply chain management, and presents SensorScheme, a platform for realizing the scenario. SensorScheme is a general purpose WSN platform, providing a safe execution environment for dynamically loaded programs. It uses high level programming primitives like marshalled communication, automatic memory management, and multiprocessing facilities. SensorScheme makes efficient use of the little available memory present in WSN nodes, to allow larger and more complex programs than the state of the art. We present a SensorScheme implementation and provide experimental results to show its compactness, speed of operation and energy efficiency.},
author = {Evers, L and Havinga, P J M and Kuper, J and Lijding, M E M and Meratnia, N},
booktitle = {2007 IEEE Conference on Emerging Technologies and Factory Automation (EFTA 2007)},
doi = {10.1109/EFTA.2007.4416802},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Evers, Havinga - 2007 - Supply Chain Management Automation using Wireless Sensor Networks.pdf:pdf},
issn = {1946-0740},
keywords = {Automatic programming,Automation,Energy efficiency,Memory management,Quality of service,RFID technology,Radiofrequency identification,SMS1,Software safety,Supply chain management,System software,Wireless sensor networks,automatic memory management,multiprocessing facilities,radiofrequency identification,supply chain management,supply chain management automation,wireless sensor networks},
mendeley-tags = {SMS1},
month = {sep},
pages = {448--455},
title = {{SensorScheme: Supply chain management automation using Wireless Sensor Networks}},
year = {2007}
}
@article{Motika2015,
abstract = {A key issue in the development of reliable embedded software is the proper handling of reactive control-flow, which typically involves concurrency. Java and its thread concept have only limited provisions for implementing deterministic concurrency. Thus, as has been observed in the past, it is challenging to develop concurrent Java programs without any deadlocks or race conditions. To alleviate this situation, the Light-weight Synchronous Java (SJL) approach presented here adopts the key concepts that have been established in the world of synchronous programming for handling reactive control-flow. Thus SJL not only provides deterministic concurrency, but also different variants of deterministic preemption. Furthermore SJL allows concurrent threads to communicate with Esterel-style signals. As a case study for an embedded system usage, we also report on how the SJL concepts have been ported to the ARM-based Lego Mindstorms NXT system. We evaluated the SJL approach to be efficient and provide experimental results comparing it to Java threads. {\textcopyright} 2014, Springer-Verlag Wien.},
author = {Motika, Christian and von Hanxleden, Reinhard},
doi = {10.1007/s00607-014-0416-7},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Motika, von Hanxleden - 2015 - Light-weight Synchronous Java (SJL) An approach for programming deterministic reactive systems with Java.pdf:pdf},
isbn = {0060701404},
issn = {0010485X},
journal = {Computing},
keywords = {Deterministic concurrency,Deterministic preemption,Java,Light-weight scheduling,Reactive systems,SMS1,Synchronous programming},
mendeley-tags = {SMS1},
number = {3},
pages = {281--307},
title = {{Light-weight Synchronous Java (SJL): An approach for programming deterministic reactive systems with Java}},
volume = {97},
year = {2015}
}
@misc{Ogden2012,
author = {Ogden, Max},
keywords = {Callback hell},
mendeley-tags = {Callback hell},
title = {{Callback Hell}},
url = {http://callbackhell.com/},
urldate = {2017-11-18},
year = {2012}
}
@article{Susilo2009,
abstract = {A ZigBee compliant wireless controller which manages multiple tasks, such as acquiring data from sensors and driving actuators, has been purposely developed for robotic capsular endoscopy applications. Preemptive priority pseudokernel, consisting of state-driven code, coroutine, and pooled-loop algorithm, has been implemented to perform hard, firm and soft real time applications. All the components have been placed on a miniaturized board ready to be integrated in a robotic capsule (max volume of 2 cm3).},
author = {Susilo, E. and Valdastri, P. and Menciassi, A. and Dario, P.},
doi = {10.1016/j.sna.2009.03.036},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Susilo et al. - 2009 - A miniaturized wireless control platform for robotic capsular endoscopy using advanced pseudokernel approach.pdf:pdf},
issn = {09244247},
journal = {Sensors and Actuators, A: Physical},
keywords = {Pseudokernel,Real time embedded system,Robotic capsular endoscopy,SMS1,Wireless miniaturized control board},
mendeley-tags = {SMS1},
number = {1},
pages = {49--58},
title = {{A miniaturized wireless control platform for robotic capsular endoscopy using advanced pseudokernel approach}},
volume = {156},
year = {2009}
}
@misc{VanderMeulen2017,
abstract = {Gartner, Inc. forecasts that 8.4 billion connected things will be in use worldwide in 2017, up 31 percent from 2016, and will reach 20.4 billion by 2020. Total spending on endpoints and services will reach almost {\$}2 trillion in 2017.},
author = {van der Meulen, Rob},
booktitle = {Press releases},
keywords = {IoT,Prediction},
mendeley-tags = {IoT,Prediction},
title = {{Gartner Says 8.4 Billion Connected "Things" Will Be in Use in 2017, Up 31 Percent From 2016}},
url = {http://www.gartner.com/newsroom/id/3598917},
urldate = {2017-08-15},
year = {2017}
}
@inproceedings{Elsts2017,
abstract = {Building large-scale low-power Internet of Things (IoT) systems remains a challenge, as these systems have to meet the requirements of reliability, robustness, and energy-efficiency while running on resource-restricted microcontrollers without memory protection. In this paper we present the case study of IoT in SPHERE (Sensor Platform for HEalthcare in a Residential Environment), a project with the objective to develop a multipurpose, multi-modal sensor platform for monitoring people's health inside their homes. Atypically for academic projects, in 2017 the SPHERE software is going to be deployed in a 100-home study in volunteer homes, therefore it has to satisfy many real-world requirements. We discuss the requirements for IoT networking in this project, the IoT architecture (built on top of Contiki OS), software engineering challenges and lessons learned, as well as some of the general aspects that still make embedded low-power IoT software development difficult.},
author = {Elsts, Atis and Oikonomou, George and Fafoutis, Xenofon and Piechocki, Robert},
booktitle = {2017 Global Internet of Things Summit (GIoTS)},
doi = {10.1109/GIOTS.2017.8016226},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Elsts et al. - 2017 - Internet of Things for smart homes Lessons learned from the SPHERE case study.pdf:pdf},
isbn = {9781509058730},
keywords = {Coroutines,Hardware,IEEE 802.15 Standard,Internet of Things,IoT,Logic gates,Protocols,Reliability,SMS1,SPHERE case study,Servers,Software,assisted living,blocking,embedded low-power IoT software development,energy-efficiency,large-scale low-power Internet of Things systems,multipurpose multimodal sensor platform,power aware computing,real-world requirements,resource-restricted microcontrollers,sensor platform for healthcare in a residential en,sensors,smart homes,software engineering,software engineering challenges,volunteer homes},
mendeley-tags = {Coroutines,SMS1,blocking},
pages = {1--6},
title = {{Internet of Things for smart homes: Lessons learned from the SPHERE case study}},
year = {2017}
}
@inproceedings{Oldewurtel2009,
abstract = {We present the RUNES architecture for reconfigurable embedded networked systems and wireless sensor networks. It is the first systems-level architecture for such networks to explicitly deal with heterogeneity in hardware platforms, link-layer technologies and networking protocols while offering a simple programming language independent set of APIs together with a component-oriented middleware for the application developers to work on. The solutions developed are particularly appropriate for use in various emergency response scenarios, in which reconfigurability is often a key requirement. We also report on an example realisation of our architecture in a prototypical demonstration environment in a particular emergency scenario. The evaluation of architectural aspects such as reconfigurability shows that great programming flexibility can be achieved at low implementation overhead. The experience gained from RUNES modular architecture are very promising both in academic and industry projects context.},
author = {Oldewurtel, Frank and Riihij{\"{a}}rvi, Janne and Rerkrai, Krisakorn and M{\"{a}}h{\"{o}}nen, Petri},
booktitle = {2009 Third International Conference on Sensor Technologies and Applications},
doi = {10.1109/SENSORCOMM.2009.26},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Oldewurtel et al. - 2009 - The RUNES Architecture for Reconfigurable Embedded and Sensor Networks.pdf:pdf},
isbn = {9780769536699},
keywords = {SMS1},
mendeley-tags = {SMS1},
pages = {109--116},
title = {{The RUNES Architecture for Reconfigurable Embedded and Sensor Networks}},
year = {2009}
}
@article{Liskov1988,
abstract = {This paper deals with the integration of an efficient asynchronous remote procedure call mechanism into a programming language. It describes a new data type called a promise that was designed to support asynchronous calls. Promises allow a caller to run in parallel with a call and to pick up the results of the call, including any exceptions it raises, in a convenient and type-safe manner. The paper also discusses efficient composition of sequences of asynchronous calls to different locations in a network.},
author = {Liskov, B. and Shrira, L.},
doi = {10.1145/960116.54016},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Liskov, Shrira - 1988 - Promises linguistic support for efficient asynchronous procedure calls in distributed systems.pdf:pdf},
isbn = {0897912691},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {Asynchronous,Distributed,Promises},
mendeley-tags = {Asynchronous,Distributed,Promises},
number = {7},
pages = {260--267},
title = {{Promises: linguistic support for efficient asynchronous procedure calls in distributed systems}},
url = {http://dl.acm.org/citation.cfm?id=54016},
volume = {23},
year = {1988}
}
@misc{George2014b,
abstract = {There is a multitude of modules and boards from different sources which carry the ESP8266 chip. MicroPython tries to provide a generic port which would run on as many boards/modules as possible, but there may be limitations. Adafruit Feather HUZZAH board is taken as a reference board for the port (for example, testing is performed on it). If you have another board, please make sure you have a datasheet, schematics and other reference materials for your board handy to look up various aspects of your board functioning.},
author = {George, Damien P. and Sokolovsky, Paul},
keywords = {ESP8266,Micropython},
mendeley-tags = {ESP8266,Micropython},
title = {{General information about the ESP8266 port — MicroPython 1.9.4 documentation}},
url = {http://docs.micropython.org/en/latest/esp8266/esp8266/general.html},
urldate = {2018-09-04},
year = {2014}
}
@inproceedings{Petersen2008,
abstract = {BACKGROUND: A software engineering systematic map is a defined method to build a classification scheme and structure a software engineering field of interest. The analysis of results focuses on frequencies of publications for categories within the scheme. Thereby, the coverage of the research field can be determined. Different facets of the scheme can also be combined to answer more specific research questions. OBJECTIVE: We describe how to conduct a systematic mapping study in software engineering and provide guidelines. We also compare systematic maps and systematic reviews to clarify how to chose between them. This comparison leads to a set of guidelines for systematic maps. METHOD: We have defined a systematic mapping process and applied it to complete a systematic mapping study. Furthermore, we compare systematic maps with systematic reviews by systematically analyzing existing systematic reviews. RESULTS: We describe a process for software engineering systematic mapping studies and compare it to systematic reviews. Based on this, guidelines for doing systematic maps are defined. CONCLUSIONS: Systematic maps and reviews are different in terms of goals, breadth, validity issues and implications. Thus, they should be used complementarily and require different methods (e.g., for analysis).},
annote = {[1] Kai Petersen, Robert Feldt, Shahid Mujtaba, and Michael Mattsson. 2008. Systematic Mapping Studies in Software Engineering. In Proceedings of the 12th International Conference on Evaluation and Assessment in Software Engineering, 68--77. Retrieved from http://dl.acm.org/citation.cfm?id=2227115.2227123},
author = {Petersen, Kai and Feldt, Robert and Mujtaba, Shahid and Mattsson, Michael},
booktitle = {Proceedings of the 12th International Conference on Evaluation and Assessment in Software Engineering},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Petersen et al. - 2008 - Systematic Mapping Studies in Software Engineering.pdf:pdf},
number = {June},
pages = {68----77},
publisher = {BCS Learning {\&} Development Ltd.},
title = {{Systematic Mapping Studies in Software Engineering}},
year = {2008}
}
@techreport{Kitchenham2007,
abstract = {The objective of this report is to propose comprehensive guidelines for systematic literature reviews appropriate for software engineering researchers, including PhD students. A systematic literature review is a means of evaluating and interpreting all available research relevant to a particular research question, topic area, or phenomenon of interest. Systematic reviews aim to present a fair evaluation of a research topic by using a trustworthy, rigorous, and auditable methodology. The guidelines presented in this report were derived from three existing guidelines used by medical researchers, two books produced by researchers with social science backgrounds and discussions with researchers from other disciplines who are involved in evidence-based practice. The guidelines have been adapted to reflect the specific problems of software engineering research. The guidelines cover three phases of a systematic literature review: planning the review, conducting the review and reporting the review. They provide a relatively high level description. They do not consider the impact of the research questions on the review procedures, nor do they specify in detail the mechanisms needed to perform meta-analysis.},
archivePrefix = {arXiv},
arxivId = {1304.1186},
author = {Kitchenham, Barbara and Charters, Stuart},
booktitle = {Technical Report EBSE-2007-01},
eprint = {1304.1186},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kitchenham, Charters - 2007 - Guidelines for performing Systematic Literature reviews in Software Engineering Version 2.3.pdf:pdf},
isbn = {1595933751},
issn = {00010782},
keywords = {SLR,SMS},
mendeley-tags = {SLR,SMS},
pmid = {10853839},
title = {{Guidelines for performing Systematic Literature reviews in Software Engineering Version 2.3}},
year = {2007}
}
@misc{Python2017,
author = {{The Python Software Foundation}},
title = {{9. Classes — Python 3.6.4 documentation}},
url = {https://docs.python.org/3/tutorial/classes.html#generators},
urldate = {2018-01-31},
year = {2018}
}
@article{Kitchenham2011a,
abstract = {Context: We are strong advocates of evidence-based software engineering (EBSE) in general and systematic literature reviews (SLRs) in particular. We believe it is essential that the SLR methodology is used constructively to support software engineering research. Objective: This study aims to assess the value of mapping studies which are a form of SLR that aims to identify and categorise the available research on a broad software engineering topic. Method: We used a multi-case, participant-observer case study using five examples of studies that were based on preceding mapping studies. We also validated our results by contacting two other researchers who had undertaken studies based on preceding mapping studies and by assessing review comments related to our follow-on studies. Results: Our original case study identified 11 unique benefits that can accrue from basing research on a preceding mapping study of which only two were case specific. We also identified nine problems associated with using preceding mapping studies of which two were case specific. These results were consistent with the information obtained from the validation activities. We did not find an example of an independent research group making use of a mapping study produced by other researchers. Conclusion: Mapping studies can save time and effort for researchers and provide baselines to assist new research efforts. However, they must be of high quality in terms of completeness and rigour if they are to be a reliable basis for follow-on research. {\textcopyright} 2010 Elsevier B.V. All rights reserved.},
author = {Kitchenham, Barbara A. and Budgen, David and {Pearl Brereton}, O.},
doi = {10.1016/j.infsof.2010.12.011},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kitchenham, Budgen, Pearl Brereton - 2011 - Using mapping studies as the basis for further research - A participant-observer case study.pdf:pdf},
isbn = {0950-5849},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Case study,Mapping studies,Software engineering,Systematic literature review},
number = {6},
pages = {638--651},
publisher = {Elsevier B.V.},
title = {{Using mapping studies as the basis for further research - A participant-observer case study}},
url = {http://dx.doi.org/10.1016/j.infsof.2010.12.011},
volume = {53},
year = {2011}
}
@inproceedings{Kambona2013,
address = {New York, NY, USA},
author = {Kambona, Kennedy and Boix, Elisa Gonzalez and {De Meuter}, Wolfgang},
booktitle = {Proceedings of the 7th Workshop on Dynamic Languages and Applications},
doi = {10.1145/2489798.2489802},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kambona, Boix, De Meuter - 2013 - An Evaluation of Reactive Programming and Promises for Structuring Collaborative Web Applications.pdf:pdf},
isbn = {978-1-4503-2041-2},
keywords = {Javascript,behaviours,callbacks,event streams,futures,promises,reactive programming},
pages = {3:1----3:9},
publisher = {ACM},
series = {DYLA '13},
title = {{An Evaluation of Reactive Programming and Promises for Structuring Collaborative Web Applications}},
url = {http://doi.acm.org.elibrary.jcu.edu.au/10.1145/2489798.2489802},
year = {2013}
}
@inproceedings{VonHanxleden2009,
abstract = {SyncCharts in C (SC) extends C with control flow operators for deterministic, light-weight concurrency and preemption. SC is based on SyncCharts, a synchronous variant of Statecharts with a sound formal basis. SC implements concurrency via a simulation of multi-threading, inspired by reactive processing. This approach permits very fast context switches and allows to express SC operators with regular, sequential C code. Thus a concurrent SC program requires neither a special compiler nor OS support for concurrency. A reference implementation of SC, based on C macros, is available as open source code. SC can be used in a number of scenarios: 1) as a regular programming language, requiring just a C compiler; 2) as an intermediate target language for synthesizing graphical SyncChart models into executable code, in a traceable manner; 3) as instruction set architecture for programming precision timed (PRET) or reactive architectures, abstracting functionality from physical timing; or 4) as a virtual machine instruction set, with a very dense encoding.},
address = {New York, NY, USA},
author = {von Hanxleden, Reinhard},
booktitle = {Proceedings of the Seventh ACM International Conference on Embedded Software},
doi = {10.1145/1629335.1629366},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/von Hanxleden - 2009 - SyncCharts in C A Proposal for Light-weight, Deterministic Concurrency.pdf:pdf},
isbn = {978-1-60558-627-4},
keywords = {SMS1,SyncCharts,esterel,model-based design,multi-threading,reactive processing,statecharts,synchronous programming},
mendeley-tags = {SMS1},
pages = {225--234},
publisher = {ACM},
title = {{SyncCharts in C: A Proposal for Light-weight, Deterministic Concurrency}},
url = {http://doi.acm.org/10.1145/1629335.1629366},
year = {2009}
}
@article{Kumar2007,
abstract = {The overhead of context-switching limits efficient scheduling of multiple concurrent threads on a uniprocessor when real-time requirements exist. Existing software thread integration (STI) methods reduce context switches, but only provide synchronous thread progress within integrated functions. For the remaining, non-integrated portions of the secondary threads to run and avoid starvation, the primary thread must have adequate amounts of coarse-grain idle time (longer than two context-switches). We have developed asynchronous software thread integration (ASTI) methods which address starvation through the efficient use of coroutine calls and integration. ASTI allows threads to make independent progress efficiently and reduces the number of context switches needed through integration. Software-implemented protocol controllers are crippled by this problem; the primary thread "bit-bangs" each bit of a message onto or off of the bus, leaving only fragments of idle time shorter than a bit time. This fragmented time may be too short to recover through context switching, so only the primary thread can execute during message transmission or reception, slowing the secondary threads and potentially making them miss their deadlines. ASTI simplifies the implementation of embedded communication protocols on low-cost, moderate speed (1 - 100 MHz, 8- and 16-bit) microcontrollers. We demonstrate ASTI by replacing a standard automotive communication protocol controller (J1850) with software and generic hardware. Secondary thread performance improves significantly when compared with a traditional interrupt-based software approach.},
address = {New York, NY, USA},
author = {Kumar, Nagendra J. and Asokan, Vasanth and Shivshankar, Siddhartha and Dean, Alexander G.},
doi = {10.1145/1210268.1210270},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kumar et al. - 2007 - Efficient Software Implementation of Embedded Communication Protocol Controllers Using Asynchronous Software Threa.pdf:pdf},
issn = {1539-9087},
journal = {ACM Transactions on Embedded Computing Systems},
keywords = {Asynchronous software thread integration,J1850,SMS1,fine-grain concurrency,hardware to software migration,software-implemented communication protocol contro},
mendeley-tags = {SMS1},
month = {feb},
number = {1},
publisher = {ACM},
title = {{Efficient Software Implementation of Embedded Communication Protocol Controllers Using Asynchronous Software Thread Integration with Time- and Space-efficient Procedure Calls}},
url = {http://portal.acm.org/citation.cfm?doid=1210268.1210270 http://doi.acm.org/10.1145/1210268.1210270},
volume = {6},
year = {2007}
}
@inproceedings{Park2015,
abstract = {Mission critical embedded software for autonomous operation requires high development cost due to its long development cycle. One of the potential solutions for reducing the cost is to reuse the software developed at previous missions. Virtual machine platform such as JVM is a good example to provide code portability across various missions. Flight software in aerospace field is adopting this concept to improve reusability and eventually to reduce development cost. In this paper, we propose a Lua-based virtualization environment for spacecraft flight software. Flight software for spacecraft control consists of a few tasks that are highly autonomous. Lua is chosen as the script language for programming the control tasks. Though Lua was designed with simplicity and portability, it only supports multithreading with collaborative coroutines. To support preemptive multitasking, we implement time slicing coroutines as spacecraft control processes. New coroutine scheduler is devised and time slicing functionality is added into the scheduler. Scheduler locking and message passing with external flight software are also implemented. Instead of modifying the Lua interpreter, we have exploited the debug support APIs for our implementation. For evaluation, we have implemented the flight software virtualization environment on the flight computer. Accuracy of the time slicing scheduler is also analyzed.},
author = {Park, Sihyeong and Kim, Hyungshin and Kang, Soo Yeong and Koo, Cheol Hea and Joe, Hyunwoo},
booktitle = {2015 IEEE 13th International Conference on Embedded and Ubiquitous Computing},
doi = {10.1109/EUC.2015.21},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Park et al. - 2015 - Lua-Based Virtual Machine Platform for Spacecraft On-Board Control Software.pdf:pdf},
isbn = {9781467382991},
keywords = {Lua,OBCP,SMS1,mission critical embedded software,reusability,spacecraft,virtual machine},
mendeley-tags = {SMS1},
pages = {44--51},
title = {{Lua-Based Virtual Machine Platform for Spacecraft On-Board Control Software}},
year = {2015}
}
@inproceedings{Dunkels2004,
abstract = {Wireless sensor networks are composed of large numbers of tiny networked devices that communicate untethered. For large scale networks, it is important to be able to download code into the network dynamically. We present Contiki, a lightweight operating system with support for dynamic loading and replacement of individual programs and services. Contiki is built around an event-driven kernel but provides optional preemptive multithreading that can be applied to individual processes. We show that dynamic loading and unloading is feasible in a resource constrained environment, while keeping the base system lightweight and compact.},
author = {Dunkels, A. and Gronvall, B. and Voigt, T.},
booktitle = {29th Annual IEEE International Conference on Local Computer Networks},
doi = {10.1109/LCN.2004.38},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Dunkels, Gronvall, Voigt - 2004 - Contiki - a lightweight and flexible operating system for tiny networked sensors.pdf:pdf},
isbn = {0-7695-2260-2},
keywords = {Contiki,LVL1,RTOS},
mendeley-tags = {Contiki,LVL1,RTOS},
pages = {455--462},
publisher = {IEEE (Comput. Soc.)},
title = {{Contiki - a lightweight and flexible operating system for tiny networked sensors}},
url = {http://ieeexplore.ieee.org/document/1367266/},
year = {2004}
}
@article{Atzori2010,
abstract = {This paper addresses the Internet of Things. Main enabling factor of this promising paradigm is the integration of several technologies and communications solutions. Identification and tracking technologies, wired and wireless sensor and actuator networks, enhanced communication protocols (shared with the Next Generation Internet), and distributed intelligence for smart objects are just the most relevant. As one can easily imagine, any serious contribution to the advance of the Internet of Things must necessarily be the result of synergetic activities conducted in different fields of knowledge, such as telecommunications, informatics, electronics and social science. In such a complex scenario, this survey is directed to those who want to approach this complex discipline and contribute to its development. Different visions of this Internet of Things paradigm are reported and enabling technologies reviewed. What emerges is that still major issues shall be faced by the research community. The most relevant among them are addressed in details.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Atzori, Luigi and Iera, Antonio and Morabito, Giacomo},
doi = {10.1016/j.comnet.2010.05.010},
eprint = {arXiv:1011.1669v3},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Atzori, Iera, Morabito - 2010 - The Internet of Things A survey.pdf:pdf},
isbn = {1389-1286},
issn = {13891286},
journal = {Computer Networks},
keywords = {Internet of Things,LVL1,Pervasive computing,RFID systems},
mendeley-tags = {LVL1},
number = {15},
pages = {2787--2805},
pmid = {25246403},
publisher = {Elsevier B.V.},
title = {{The Internet of Things: A survey}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1389128610001568},
volume = {54},
year = {2010}
}
@inproceedings{Edwards2009,
abstract = {Side effects are both the essence and bane of imperative programming. The programmer must carefully coordinate actions to manage their side effects upon each other. Such coordination is complex, error-prone, and fragile. Coherent reaction is a new model of change-driven computation that coordinates effects automatically. State changes trigger events called reactions that in turn change other states. A coherent execution order is one in which each reaction executes before any others that are affected by its changes. A coherent order is discovered iteratively by detecting incoherencies as they occur and backtracking their effects. Unlike alternative solutions, much of the power of imperative programming is retained, as is the common sense notion of mutable state. Automatically coordinating actions lets the programmer express what to do, not when to do it. Coherent reactions are embodied in the Coherence language, which is specialized for interactive applications like those common on the desktop and web. The fundamental building block of Coherence is the dynamically typed mutable tree. The fundamental abstraction mechanism is the virtual tree, whose value is lazily computed, and whose behavior is generated by coherent reactions.},
address = {New York, New York, USA},
author = {Edwards, Jonathan},
booktitle = {Proceeding of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications - OOPSLA '09},
doi = {10.1145/1639950.1640058},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Edwards - 2009 - Coherent reaction.pdf:pdf},
isbn = {9781605587684},
keywords = {callback hell},
mendeley-tags = {callback hell},
pages = {925},
publisher = {ACM Press},
title = {{Coherent reaction}},
url = {http://dl.acm.org/citation.cfm?doid=1639950.1640058},
year = {2009}
}
@article{Dunkels2005,
abstract = {Wireless sensor networks consist of tiny devices that usually have severe resource constraints in terms of energy, process-ing power and memory. In order to work efficiently within the constrained memory, many operating systems for such devices are based on an event-driven model rather than on multi-threading. While event-driven systems allow for re-duced memory usage, they require programs to be developed as explicit state machines. Since implementing programs as explicit state machines is hard, developing, maintaining, and debugging programs for event-driven systems is difficult. In this paper, we introduce protothreads, a programming abstraction for event-driven sensor network systems. Pro-tothreads simplify implementation of high-level functional-ity on top of event-driven systems, without significantly in-creasing the memory requirements. The memory require-ment of a protothread is that of an unsigned integer.},
author = {Dunkels, Adam and Schmidt, Oliver and Voigt, Thiemo},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Dunkels, Schmidt, Voigt - 2005 - Using protothreads for sensor node programming.pdf:pdf},
journal = {Proceedings of the REALWSN},
keywords = {Contiki,LVL1,Protothreads},
mendeley-tags = {Contiki,LVL1,Protothreads},
title = {{Using protothreads for sensor node programming}},
url = {http://www.dunkels.com/adam/dunkels05using.pdf},
year = {2005}
}
@inproceedings{Noman2017,
abstract = {Interoperability is one of the key requirements in the Internet of Things considering the diverse platforms, commu-nication standards and specifications available today. Inherent resource constraints in the majority of IoT devices makes it very difficult to use existing solutions for interoperability, thus demanding new approaches. This paper presents the process of adapting a lightweight interoperability middleware for IoT, LISA, from RIOT to Contiki OS and evaluates memory and power overheads. The middleware follows a service oriented architecture and classifies devices according to available resources to assign different roles, such as Application, Service and Manager Nodes. These roles live in different tiers in a generic IoT architecture, where the Manager nodes are located in the intermediate Fog layer. To adapt to an event based kernel of Contiki, the mid-dleware defines and handles a set of events that are used to communicate with the user application. A network of nodes is simulated to show the architecture promoted by the middleware and the results are presented.},
author = {Noman, Uzair A. and Negash, Behailu and Rahmani, Amir M. and Liljeberg, Pasi and Tenhunen, Hannu},
booktitle = {2017 14th IEEE Annual Consumer Communications and Networking Conference (CCNC)},
doi = {10.1109/CCNC.2017.7983156},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Noman et al. - 2017 - From threads to events Adapting a lightweight middleware for Contiki OS.pdf:pdf},
isbn = {9781509061969},
keywords = {Contiki,Internet of Things,Interoperability,LISA,SMS1},
mendeley-tags = {SMS1},
pages = {486--491},
title = {{From threads to events: Adapting a lightweight middleware for Contiki OS}},
year = {2017}
}
@article{Manyika2015,
abstract = {By blending physical and digital realms, the Internet of Things (IoT) vastly expands the reach of information technology. The myriad possibilities that arise from the ability to monitor and control things in the physical world electronically have inspired a surge of innovation and enthusiasm. The sweeping changes that IoT can bring to how companies manage physical assets, how consumers attend to their health and fitness, and how cities operate have also inspired visions of a very different future, as well as a good deal of hype. McKinsey has been involved in the Internet of Things over the years and we have seen how rapid advances in technology and know-how have exceeded our expectations—and yet how difficult it will be to obtain the greatest benefits of IoT implementations, which require creating highly complex systems and coordinating technology, investment, and talent across both space and time.},
author = {Manyika, James and Chui, Michael and Bisson, Peter and Woetzel, Jonathan and Dobbs, Richard and Bughin, Jacques and Aharon, Dan},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Manyika et al. - 2015 - The Internet of Things Mapping the value beyond the hype.pdf:pdf},
isbn = {978-3-319-05028-7},
issn = {1860949X},
journal = {McKinsey Global Institute},
number = {June},
pages = {144},
title = {{The Internet of Things: Mapping the value beyond the hype}},
url = {https://www.mckinsey.com/~/media/McKinsey/Business%20Functions/McKinsey%20Digital/Our%20Insights/The%20Internet%20of%20Things%20The%20value%20of%20digitizing%20the%20physical%20world/The-Internet-of-things-Mapping-the-value-beyond-the-hype.ashx},
year = {2015}
}
@misc{Dunkels2005b,
abstract = {Protothreads are a extremely lightweight, stackless threads that provides a blocking context on top of an event-driven system, without the overhead of per-thread stacks. The purpose of protothreads is to implement sequential flow of control without using complex state machines or full multi-threading. Protothreads provides conditional blocking inside a C function.},
author = {Dunkels, Adam},
keywords = {Protothreads},
mendeley-tags = {Protothreads},
title = {{About protothreads}},
url = {http://dunkels.com/adam/pt/about.html},
urldate = {2018-01-31},
year = {2005}
}
@article{Al-Fuqaha2015,
abstract = {This paper provides an overview of the Internet of Things (IoT) with emphasis on enabling technologies, protocols and application issues. The IoT is enabled by the latest developments in RFID, smart sensors, communication technologies and Internet protocols. The basic premise is to have smart sensors collaborate directly without human involvement to deliver a new class of applications. The current revolution in Internet, mobile and machine-to-machine (M2M) technologies can be seen as the first phase of the IoT. In the coming years, the IoT is expected to bridge diverse technologies to enable new applications by connecting physical objects together in support of intelligent decision making. This paper starts by providing a horizontal overview of the IoT. Then, we give an overview of some technical details that pertain to the IoT enabling technologies, protocols and applications. Compared to other survey papers in the field, our objective is to provide a more thorough summary of the most relevant protocols and application issues to enable researchers and application developers to get up to speed quickly on how the different protocols fit together to deliver desired functionalities without having to go through RFCs and the standards specifications. We also provide an overview of some of the key IoT challenges presented in the recent literature and provide a summary of related research work. Moreover, we explore the relation between the IoT and other emerging technologies including big data analytics and cloud and fog computing. We also present the need for better horizontal integration among IoT services. Finally, we present detailed service use-cases to illustrate how the different protocols presented in the paper fit together to deliver desired IoT services.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Al-Fuqaha, Ala and Guizani, Mohsen and Mohammadi, Mehdi and Aledhari, Mohammed and Ayyash, Moussa},
doi = {10.1109/COMST.2015.2444095},
eprint = {arXiv:1011.1669v3},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Al-Fuqaha et al. - 2015 - Internet of Things A Survey on Enabling Technologies, Protocols, and Applications.pdf:pdf},
isbn = {1553-877X},
issn = {1553877X},
journal = {IEEE Communications Surveys and Tutorials},
keywords = {AMQP,CoAP,DDS,Internet of Things (IoT),IoT gateway,LVL2,MQTT,XMPP,mDNS},
mendeley-tags = {LVL2},
number = {4},
pages = {2347--2376},
pmid = {15487673},
title = {{Internet of Things: A Survey on Enabling Technologies, Protocols, and Applications}},
volume = {17},
year = {2015}
}
@misc{Barry2018,
abstract = {Developed in partnership with the world's leading chip companies over a 14 year period, the FreeRTOS kernel is a market leading real time operating system (or RTOS), and the de-facto standard solution for microcontrollers and small microprocessors.},
author = {Barry, Richard},
keywords = {FreeRTOS},
mendeley-tags = {FreeRTOS},
title = {{The FreeRTOS Kernel}},
url = {https://www.freertos.org/},
urldate = {2018-02-02},
year = {2018}
}
@inproceedings{Bierman2012,
abstract = {Writing applications that connect to external services and yet remain responsive and resource conscious is a difficult task. With the rise of web programming this has become a common problem. The solution lies in using asynchronous operations that separate issuing a request from waiting for its completion. However, doing so in common object-oriented languages is difficult and error prone. Asynchronous operations rely on callbacks, forcing the programmer to cede control. This inversion of control-flow impedes the use of structured control constructs, the staple of sequential code. In this paper, we describe the language support for asynchronous programming in the upcoming version of C {\$}{\^{}}\backslashsharp{\$} . The feature enables asynchronous programming using structured control constructs. Our main contribution is a precise mathematical description that is abstract (avoiding descriptions of compiler-generated state machines) and yet sufficiently concrete to allow important implementation properties to be identified and proved correct.},
address = {Berlin, Heidelberg},
author = {Bierman, Gavin and Russo, Claudio and Mainland, Geoffrey and Meijer, Erik and Torgersen, Mads},
booktitle = {ECOOP 2012 -- Object-Oriented Programming},
doi = {10.1007/978-3-642-31057-7_12},
editor = {Noble, James},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Bierman et al. - 2012 - Pause 'n' Play Formalizing Asynchronous C sharp.pdf:pdf},
isbn = {978-3-642-31057-7},
keywords = {LVL1,async,asyncawait,await,csharp},
mendeley-tags = {LVL1,async,asyncawait,await,csharp},
pages = {233--257},
publisher = {Springer Berlin Heidelberg},
title = {{Pause 'n' Play: Formalizing Asynchronous C sharp}},
url = {https://pdfs.semanticscholar.org/cb1c/8e5ff90ecffd438c446595d0056d613669c7.pdf},
year = {2012}
}
@inproceedings{Strube2010,
abstract = {We present an integrated approach for supporting in-network sensor data processing in dynamic and heterogeneous sensor networks. The concept relies on data stream processing techniques that define and optimize the distribution of queries and their operators. We anticipate a high degree of dynamics in the network, which can for example be expected in the case of wildlife monitoring applications. The distribution of operators to individual nodes demands system level capabilities not available in current sensor node operating systems. In particular, we present a system for seamless and on demand operator migration between sensor nodes. Our framework, which we implemented for Contiki running on TelosB nodes, supports stateful module migration including selected parts of the code and data sections.},
author = {Strube, M and Daum, M and Kapitza, R and Villanueva, F and Dressler, F},
booktitle = {The 7th IEEE International Conference on Mobile Ad-hoc and Sensor Systems (IEEE MASS 2010)},
doi = {10.1109/MASS.2010.5663821},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Str{\"{u}}be et al. - 2010 - Dynamic operator replacement in sensor networks.pdf:pdf},
issn = {2155-6806},
keywords = {Contiki running,Data processing,Distributed databases,Operating systems,Programming,Runtime,SMS1,Servers,TelosB nodes,Wireless sensor networks,data stream processing,dynamic operator replacement,dynamic sensor networks,heterogeneous sensor networks,in-network sensor data processing,optimisation,optimization,wireless sensor networks},
mendeley-tags = {SMS1},
month = {nov},
pages = {748--750},
title = {{Dynamic operator replacement in sensor networks}},
year = {2010}
}
@misc{ECMA2017,
abstract = {Async Function Definitions},
author = {ECMA},
title = {{ECMAScript Latest Draft (ECMA-262) Async Function Definitions}},
url = {https://tc39.github.io/ecma262/#sec-async-function-definitions},
year = {2017}
}
@article{Gubbi2013,
abstract = {Ubiquitous sensing enabled by Wireless Sensor Network (WSN) technologies cuts across many areas of modern day living. This offers the ability to measure, infer and understand environmental indicators, from delicate ecologies and natural resources to urban environments. The proliferation of these devices in a communicating-actuating network creates the Internet of Things (IoT), wherein sensors and actuators blend seamlessly with the environment around us, and the information is shared across platforms in order to develop a common operating picture (COP). Fueled by the recent adaptation of a variety of enabling wireless technologies such as RFID tags and embedded sensor and actuator nodes, the IoT has stepped out of its infancy and is the next revolutionary technology in transforming the Internet into a fully integrated Future Internet. As we move from www (static pages web) to web2 (social networking web) to web3 (ubiquitous computing web), the need for data-on-demand using sophisticated intuitive queries increases significantly. This paper presents a Cloud centric vision for worldwide implementation of Internet of Things. The key enabling technologies and application domains that are likely to drive IoT research in the near future are discussed. A Cloud implementation using Aneka, which is based on interaction of private and public Clouds is presented. We conclude our IoT vision by expanding on the need for convergence of WSN, the Internet and distributed computing directed at technological research community. ?? 2013 Elsevier B.V. All rights reserved.},
archivePrefix = {arXiv},
arxivId = {1207.0203},
author = {Gubbi, Jayavardhana and Buyya, Rajkumar and Marusic, Slaven and Palaniswami, Marimuthu},
doi = {10.1016/j.future.2013.01.010},
eprint = {1207.0203},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Gubbi et al. - 2013 - Internet of Things (IoT) A vision, architectural elements, and future directions.pdf:pdf},
isbn = {0167739X},
issn = {0167739X},
journal = {Future Generation Computer Systems},
keywords = {Cloud computing,Internet of Things,LVL1,RFID Smart environments,Ubiquitous sensing,Wireless sensor networks},
mendeley-tags = {LVL1},
number = {7},
pages = {1645--1660},
pmid = {20120930},
publisher = {Elsevier B.V.},
title = {{Internet of Things (IoT): A vision, architectural elements, and future directions}},
url = {http://dx.doi.org/10.1016/j.future.2013.01.010},
volume = {29},
year = {2013}
}
@inproceedings{Andersen2016,
abstract = {Modern IoT prototyping platforms fall short in terms of energy efficiency, connectivity and software programming practices. We present the design of a new hardware and software platform that addresses these shortcomings by bringing together Mobile, Wearable, Maker and Wireless Sensor Network technologies to enable rapid prototyping with a high degree of synergy and energy efficiency. This is achieved in part by leveraging the Memory Protection Unit on modern microcontrollers along with a novel syscall interface to provide kernel / user isolation and a clean concurrency model. Such a design allows a wide range of languages to be used for application development without significant adaptation. We demonstrate how careful choice of application language allows the naturally asynchronous nature of embedded programming to be expressed cleanly and powerfully. Finally we evaluate the platform in several integrated use cases, providing examples of the capabilities introduced by Synergy.},
address = {Vienna, Austria},
author = {Andersen, Michael P. and Fierro, Gabe and Culler, David E.},
booktitle = {2016 15th ACM/IEEE International Conference on Information Processing in Sensor Networks (IPSN)},
doi = {10.1109/IPSN.2016.7460722},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Andersen, Fierro, Culler - 2016 - System Design for a Synergistic, Low Power MoteBLE Embedded Platform.pdf:pdf},
isbn = {978-1-5090-0802-5},
keywords = {LVL0,LVL1,SMS1},
mendeley-tags = {LVL0,LVL1,SMS1},
month = {apr},
pages = {1--12},
publisher = {IEEE},
title = {{System Design for a Synergistic, Low Power Mote/BLE Embedded Platform}},
url = {http://ieeexplore.ieee.org/document/7460722/},
year = {2016}
}
@article{Weber2015,
abstract = {A B S T R A C T The Internet of Things presents unique challenges to the protection of individual privacy. This article highlights the growing need for appropriate regulatory as well as technical action in order to bridge the gap between the automated surveillance by IoT devices and the rights of individuals who are often unaware of the potential privacy risk to which they are exposed. As a result, new legal approaches for the protection of privacy need to be developed.},
annote = {http://ac.els-cdn.com.elibrary.jcu.edu.au/S0267364915001156/1-s2.0-S0267364915001156-main.pdf?{\_}tid=5717bede-111d-11e7-9589-00000aab0f01{\&}acdnat=1490420517{\_}138a4d7485a7e9042941b11b5eeecf4e},
author = {Weber, Rolf H},
doi = {10.1016/j.clsr.2015.07.002},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Weber - 2015 - Internet of things Privacy issues revisited.pdf:pdf},
journal = {Computer Law {\&} Security Review: The International Journal of Technology Law and Practice},
keywords = {Data minimization,Internet of things,LVL2,Privacy,Privacy challenges,Privacy enhancing technologies,Quality of data,Security,Transparency},
mendeley-tags = {LVL2,Privacy,Security},
pages = {618--627},
title = {{Internet of things: Privacy issues revisited}},
volume = {31},
year = {2015}
}
@inproceedings{Dunkels2006,
abstract = {Event-driven programming is a popular model for writing programs for tiny embedded systems and sensor network nodes. While event-driven programming can keep the memory overhead down, it enforces a state machine programming style which makes many programs difficult to write, maintain, and debug. We present a novel programming abstraction called protothreads that makes it possible to write event-driven programs in a thread-like style, with a memory overhead of only two bytes per protothread. We show that protothreads significantly reduce the complexity of a number of widely used programs previously written with event-driven state machines. For the examined programs the majority of the state machines could be entirely removed. In the other cases the number of states and transitions was drastically decreased. With protothreads the number of lines of code was reduced by one third. The execution time overhead of protothreads is on the order of a few processor cycles.},
address = {New York, New York, USA},
author = {Dunkels, Adam and Schmidt, Oliver and Voigt, Thiemo and Ali, Muneeb},
booktitle = {Proceedings of the 4th International Conference on Embedded Networked Sensor Systems},
doi = {10.1145/1182807.1182811},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Dunkels et al. - 2006 - Protothreads Simplifying Event-driven Programming of Memory-constrained Embedded Systems.pdf:pdf},
isbn = {1595933433},
keywords = {LVL0,LVL1,Protothreads,embedded systems,threads,wireless sensor networks},
mendeley-tags = {LVL0,LVL1,Protothreads},
pages = {29----42},
publisher = {ACM Press},
title = {{Protothreads: Simplifying Event-driven Programming of Memory-constrained Embedded Systems}},
url = {http://portal.acm.org/citation.cfm?doid=1182807.1182811},
year = {2006}
}
@article{Petersen2015,
abstract = {Context Systematic mapping studies are used to structure a research area, while systematic reviews are focused on gathering and synthesizing evidence. The most recent guidelines for systematic mapping are from 2008. Since that time, many suggestions have been made of how to improve systematic literature reviews (SLRs). There is a need to evaluate how researchers conduct the process of systematic mapping and identify how the guidelines should be updated based on the lessons learned from the existing systematic maps and SLR guidelines. Objective To identify how the systematic mapping process is conducted (including search, study selection, analysis and presentation of data, etc.); to identify improvement potentials in conducting the systematic mapping process and updating the guidelines accordingly. Method We conducted a systematic mapping study of systematic maps, considering some practices of systematic review guidelines as well (in particular in relation to defining the search and to conduct a quality assessment). Results In a large number of studies multiple guidelines are used and combined, which leads to different ways in conducting mapping studies. The reason for combining guidelines was that they differed in the recommendations given. Conclusion The most frequently followed guidelines are not sufficient alone. Hence, there was a need to provide an update of how to conduct systematic mapping studies. New guidelines have been proposed consolidating existing findings.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Petersen, Kai and Vakkalanka, Sairam and Kuzniarz, Ludwik},
doi = {10.1016/j.infsof.2015.03.007},
eprint = {arXiv:1011.1669v3},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Petersen, Vakkalanka, Kuzniarz - 2015 - Guidelines for conducting systematic mapping studies in software engineering An update.pdf:pdf},
isbn = {0360-1315},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Guidelines,Review,SLR,Software engineering,Systematic mapping studies},
mendeley-tags = {Review,SLR},
pages = {1--18},
pmid = {25246403},
publisher = {Elsevier B.V.},
title = {{Guidelines for conducting systematic mapping studies in software engineering: An update}},
url = {http://dx.doi.org/10.1016/j.infsof.2015.03.007},
volume = {64},
year = {2015}
}
@misc{AspenCore2017,
author = {{AspenCore Global Media}},
booktitle = {EE Times},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/AspenCore Global Media - 2017 - 2017 Embedded Markets Study.pdf:pdf},
keywords = {Embedded,Survey},
mendeley-tags = {Embedded,Survey},
number = {April},
title = {{2017 Embedded Markets Study}},
url = {http://m.eet.com/media/1246048/2017-embedded-market-study.pdf},
urldate = {2017-08-29},
year = {2017}
}
@article{Goldthwaite2006,
author = {Goldthwaite, Lois},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage//IsoIec - 2006 - Technical Report on C Performance.pdf:pdf},
journal = {ISO/IEC PDTR},
title = {{Technical report on C++ performance}},
volume = {18015},
year = {2006}
}
@article{Andersen2017b,
abstract = {To enable a prosperous Internet of Things (IoT), devices and services must be extensible and adapt to changes in the environment or user interaction patterns. These requirements manifest as a set of design principles for each of the layers in an IoT ecosystem, from hardware to cloud services. This paper gives concrete guidelines learned from implementing and deploying a full-stack synergistic IoT platform. We address hardware design concerns and present a reference platform, Firestorm. Upon this platform, we demonstrate firmware and personal-area networking concerns and solutions. Moving out towards larger scales we address local service discovery and syndication, and show how these principles carry through to global operation where security concerns dominate.},
author = {Andersen, Michael P. and Fierro, Gabe and Culler, David E.},
doi = {10.1016/j.jnca.2016.10.017},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Andersen, Fierro, Culler - 2017 - Enabling synergy in IoT Platform to service and beyond.pdf:pdf},
isbn = {9781467399487},
issn = {1084-8045},
journal = {Journal of Network and Computer Applications},
keywords = {Embedded operating systems,Internet of Things,LVL0,LVL1,Middleware,Publish-subscribe,SMS1,Security,Sensor motes,Trust,Wireless sensor networks},
mendeley-tags = {LVL0,LVL1,SMS1},
pages = {96--110},
title = {{Enabling synergy in IoT: Platform to service and beyond}},
volume = {81},
year = {2017}
}
@article{Boers2010,
abstract = {We describe our “holistic” platform for devel- oping wireless ad hoc sensor networks and focus on its most representative and essential virtualization component: VUE2 (the Virtual Underlay Emulation Engine). Its role is to provide a vehicle for the authoritative emulation of com- plete networked applications before physically deploying any wireless nodes. The goal is to be able to verify those ap- plications exhaustively before programming the hardware, such that no further (field) tests are necessary. We explain how VUE2 achieves this goal owing to several facilitating factors, most notably the powerful programming paradigm that our platform adopts. As implied by the holistic nature of the discussed system, our work touches upon operating systems, simulation, network protocols, real-time systems, and programming methodology.},
author = {Boers, Nicholas M. and Gburzy{\'{n}}ski, Pawe{\l} and Nikolaidis, Ioanis and Olesi{\'{n}}ski, W{\l}odek},
doi = {10.1007/s11235-009-9246-x},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Boers et al. - 2010 - Developing wireless sensor network applications in a virtual environment.pdf:pdf},
issn = {10184864},
journal = {Telecommunication Systems},
keywords = {Application development,SMS1,Virtualization,Wireless sensor network},
mendeley-tags = {SMS1},
number = {2-3},
pages = {165--176},
title = {{Developing wireless sensor network applications in a virtual environment}},
volume = {45},
year = {2010}
}
@misc{Tatham2000,
author = {Tatham, Simon},
isbn = {0201896834},
publisher = {Addison-Wesley},
title = {{Coroutines in C}},
url = {https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html},
urldate = {2017-06-19},
year = {2000}
}
@inproceedings{Stroustrup1986,
address = {New York, NY, USA},
author = {Stroustrup, Bjarne},
booktitle = {Proceedings of the 1986 SIGPLAN Workshop on Object-oriented Programming},
doi = {10.1145/323779.323736},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Stroustrup - 1986 - An Overview of C.pdf:pdf},
isbn = {0-89791-205-5},
pages = {7--18},
publisher = {ACM},
series = {OOPWORK '86},
title = {{An Overview of C++}},
url = {http://doi.acm.org/10.1145/323779.323736},
year = {1986}
}
@article{Levis2002,
abstract = {OBJECTIVE: To modify the traditional heuristic evaluation method of assessing software usability so that it can be applied to medical devices and used to evaluate the patient safety of those devices through the identification and assessment of usability problems. DESIGN: Heuristic evaluation, a usability inspection method commonly used for software usability evaluation, was modified and extended for medical devices. The modified method was used to evaluate and compare the patient safety of two 1-channel volumetric infusion pumps. RESULTS: The modified heuristic evaluation method was successfully applied to medical devices. One hundred and ninety-two heuristic violations were categorized for 89 usability problems identified for Pump 1, and 121 heuristic violations were categorized for the 52 usability problems identified for Pump 2. Pump 1 had more usability problems with high severity ratings than Pump 2. In general, Pump 1 was found to have more usability issues that are likely to induce more medical errors. CONCLUSIONS: Heuristic evaluation, when modified for medical devices, is a useful, efficient, and low cost method for evaluating patient safety features of medical devices through the identification of usability problems and their severities},
author = {Levis, Philip and Culler, David},
doi = {10.1145/605397.605407},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Levis, Culler - 2002 - Mate A Tiny Virtual Machine for Sensor Networks.pdf:pdf},
isbn = {1581135742},
issn = {01635964},
journal = {ACM SIGPLAN Notices},
keywords = {LVL1},
mendeley-tags = {LVL1},
number = {10},
pages = {85--95},
pmid = {14552844},
title = {{Mate : A Tiny Virtual Machine for Sensor Networks}},
url = {http://www.cs.berkeley.edu/{~}pal/pubs/mate.pdf},
volume = {37},
year = {2002}
}
@article{Tismer2000,
annote = {http://www.python.org/workshops/2000-01/proceedings.html},
author = {Tismer, C.},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Tismer - 2000 - Continuations and stackless Python.pdf:pdf},
journal = {Proceedings of the 8th International Python Conference},
pages = {2000--01},
title = {{Continuations and stackless Python}},
url = {https://svn.python.org/www/trunk/pydotorg/workshops/2000-01/proceedings/papers/tismers/spcpaper.doc},
year = {2000}
}
@book{Marlin1979,
author = {Marlin, Christopher D},
editor = {Goos, G and Hartmanis, J},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Marlin - 1979 - Coroutines A Programming Methodology, a Language Design and an Implementation.pdf:pdf},
number = {95},
publisher = {Springer, Berlin, Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Coroutines: A Programming Methodology, a Language Design and an Implementation}},
year = {1979}
}
@techreport{Kitchenham2004,
abstract = {The objective of this report is to propose a guideline for systematic reviews appropriate for software engineering researchers, including PhD students. A systematic review is a means of evaluating and interpreting all available research relevant to a particular research question, topic area, or phenomenon of interest. Systematic reviews aim to present a fair evaluation of a research topic by using a trustworthy, rigorous, and auditable methodology. The guideline presented in this report was derived from three existing guidelines used by medical researchers. The guideline has been adapted to reflect the specific problems of software engineering research. The guideline covers three phases of a systematic review: planning the review, conducting the review and reporting the review. It is at a relatively high level. It does not consider the impact of question type on the review procedures, nor does it specify in detail mechanisms needed to undertake meta-analysis.},
author = {Kitchenham, Barbara},
booktitle = {Keele, UK, Keele University},
doi = {10.1.1.122.3308},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kitchenham - 2004 - Procedures for performing systematic reviews.pdf:pdf},
isbn = {1353-7776},
issn = {13537776},
keywords = {LVL3},
mendeley-tags = {LVL3},
number = {TR/SE-0401},
pages = {28},
pmid = {15046037},
title = {{Procedures for performing systematic reviews}},
url = {http://csnotes.upm.edu.my/kelasmaya/pgkm20910.nsf/0/715071a8011d4c2f482577a700386d3a/{\$}FILE/10.1.1.122.3308[1].pdf{\%}5Cnhttp://tests-zingarelli.googlecode.com/svn-history/r336/trunk/2-Disciplinas/MetodPesquisa/kitchenham{\_}2004.pdf},
volume = {33},
year = {2004}
}
@inbook{Niebert2014,
abstract = {We present a design approach for ``smart surfaces'' inspired by cellular automata. The aim is to construct and to program scalable distributed realtime interactive systems composed of inexpensive microcontrollers to build surfaces that interact physically with their environment. Our work is both pragmatic and integrated: it covers the entire chain from hardware considerations, a programming model based on a networked locally synchronous virtual machine, dedicated programming language features, a distributed embedded implementation and an integrated programming environment with a simulator implementation of the locally synchronous virtual machine.},
address = {Cham},
author = {Niebert, Peter and Caralp, Mathieu},
booktitle = {Theory and Practice of Natural Computing, TPNC 2014. Lecture Notes in Computer Science, vol 8890.},
doi = {10.1007/978-3-319-13749-0_2},
editor = {Dediu, Adrian-Horia and Lozano, Manuel and Mart{\'{i}}n-Vide, Carlos},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Sipper - 1997 - Cellular Programming.pdf:pdf},
isbn = {978-3-319-13749-0},
keywords = {SMS1},
mendeley-tags = {SMS1},
pages = {11--22},
publisher = {Springer International Publishing},
title = {{Cellular Programming}},
url = {https://doi.org/10.1007/978-3-319-13749-0{\_}2 http://link.springer.com/10.1007/978-3-319-13749-0{\_}2},
year = {2014}
}
@inproceedings{Durmaz2017,
address = {Dagstuhl, Germany},
annote = {From Duplicate 2 (Modelling Contiki-Based IoT Systems - Durmaz, Caglar; Challenger, Moharram; Dagdeviren, Orhan; Kardas, Geylani)

Keywords: Domain-specific Modelling, Metamodel, Model-driven Engineering, Internet of Things, Wireless Sensor Networks, Embedded Software, Contiki Operating Sys},
author = {Durmaz, Caglar and Challenger, Moharram and Dagdeviren, Orhan and Kardas, Geylani},
booktitle = {6th Symposium on Languages, Applications and Technologies (SLATE 2017)},
doi = {10.4230/OASIcs.SLATE.2017.5},
editor = {Queir{\'{o}}s, Ricardo and Pinto, M{\'{a}}rio and Sim{\~{o}}es, Alberto and Leal, Jos{\'{e}} Paulo and Varanda, Maria Jo{\~{a}}o},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Durmaz et al. - 2017 - Modelling Contiki-Based IoT Systems.pdf:pdf},
isbn = {978-3-95977-056-9},
issn = {2190-6807},
keywords = {2017,4230,5,SMS1,and phrases domain-specific modelling,contiki operating system,digital object identifier 10,embedded software,in-,metamodel,model-driven engineering,oasics,slate,ternet of things,wireless sensor networks},
mendeley-tags = {SMS1},
number = {5},
pages = {5:1----5:13},
publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
series = {OpenAccess Series in Informatics (OASIcs)},
title = {{Modelling Contiki-Based IoT Systems}},
url = {http://drops.dagstuhl.de/opus/volltexte/2017/7940},
volume = {56},
year = {2017}
}
@inproceedings{Karpin2007,
abstract = {Programming Wireless Sensor Network (WSN) applications is known to be a difficult task. Part of the problem is that the resource limitations of typical WSN nodes force programmers to use relatively low-level techniques to deal with the logical concurrency and asynchronous event handling inherent in these applications. In addition, existing general-purpose, nodelevel programming tools only support the networked nature of WSN applications in a limited way and result in application code that is hardly portable across different software platforms. All of this makes programming a single device a tedious and error-prone task. To address these issues we propose a high-level programming model that allows programmers to express applications as hierarchical state machines and to handle events and application concurrency in a way similar to imperative synchronous languages. Our program execution model is based on static scheduling what allows for standalone application analysis and testing. For deployment, the resulting programs are translated into efficient sequential C code. A prototype compiler for TinyOS has been implemented and its evaluation in described in this paper.},
author = {Karpinski, Marcin and Cahill, Vinny},
booktitle = {2007 4th Annual IEEE Communications Society Conference on Sensor, Mesh and Ad Hoc Communications and Networks},
doi = {10.1109/SAHCN.2007.4292873},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Karpinski, Cahill - 2007 - High-Level Application Development is Realistic for Wireless Sensor Networks.pdf:pdf},
isbn = {1424412684},
keywords = {Application software,Computer languages,Computer science,Concurrent computing,Hardware,Operating systems,Peer to peer computing,Programming profession,Prototypes,SMS1,Wireless sensor networks},
mendeley-tags = {SMS1},
pages = {610--619},
title = {{High-Level Application Development is Realistic for Wireless Sensor Networks}},
year = {2007}
}
@inbook{Levis2005,
abstract = {We present TinyOS, a flexible, application-specific operating system for sensor networks, which form a core component of ambient intelligence systems. Sensor networks consist of (potentially) thousands of tiny, low-power nodes, each of which execute concurrent, reactive programs that must operate with severe memory and power constraints. The sensor network challenges of limited resources, event-centric concurrent applications, and low-power operation drive the design of TinyOS. Our solution combines flexible, fine-grain components with an execution model that supports complex yet safe concurrent operations. TinyOS meets these challenges well and has become the platform of choice for sensor network research; it is in use by over a hundred groups worldwide, and supports a broad range of applications and research topics. We provide a qualitative and quantitative evaluation of the system, showing that it supports complex, concurrent programs with very low memory requirements (many applications fit within 16KB of memory, and the core OS is 400 bytes) and efficient, low-power operation.We present our experiences with TinyOS as a platform for sensor network innovation and applications.},
address = {Berlin, Heidelberg},
author = {Levis, P and Madden, S and Polastre, J and Szewczyk, R and Whitehouse, K and Woo, A and Gay, D and Hill, J and Welsh, M and Brewer, E and Culler, D},
booktitle = {Ambient Intelligence},
doi = {10.1007/3-540-27139-2_7},
editor = {Weber, Werner and Rabaey, Jan M and Aarts, Emile},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Levis et al. - 2005 - TinyOS An Operating System for Sensor Networks.pdf:pdf},
isbn = {978-3-540-27139-0},
pages = {115--148},
publisher = {Springer Berlin Heidelberg},
title = {{TinyOS: An Operating System for Sensor Networks}},
url = {https://doi.org/10.1007/3-540-27139-2{\_}7},
year = {2005}
}
@misc{Tismer2018,
abstract = {Stackless Python is an enhanced version of the Python programming language. It allows programmers to reap the benefits of thread-based programming without the performance and complexity problems associated with conventional threads. The microthreads that Stackless adds to Python are a cheap and lightweight convenience which can if used properly, give the following benefits: Improved program structure. More readable code. Increased programmer productivity.},
author = {Tismer, Christian},
title = {{About Stackless}},
url = {https://github.com/stackless-dev/stackless/wiki},
urldate = {2018-09-04},
year = {2018}
}
@unpublished{Romer2018,
abstract = {The Coroutines TS provides users with an elegant and efficient abstraction for writing asynchronous code. We mean that as both sincere praise, and as a critique: the Coroutines TS provides an abstraction, but it does not provide programmers with the facilities they need to define their own elegant and efficient abstractions. Furthermore, the TS's abstraction prioritizes the asynchronous use case in a variety of ways, which prevents it from being general-purpose. It gives programmers ways of extending and reusing the asynchrony abstraction, but they remain locked into many of the design tradeoffs motivated by the original use case. Fundamentally, the Coroutines TS does not provide a direct and efficient model of hardware1: the primitive objects and operations that are used to implement coroutines are hidden behind an abstraction boundary.},
author = {Romer, Geoff and Dennett, James and Carruth, Chandler},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Romer, Dennett, Carruth - 2018 - P1063R0 - Core Coroutines Making coroutines simpler, faster, and more general.pdf:pdf},
title = {{P1063R0 - Core Coroutines Making coroutines simpler, faster, and more general}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1063r0.pdf},
year = {2018}
}
