Automatically generated by Mendeley Desktop 1.18
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@misc{Haller2016,
abstract = {This is a proposal to add constructs that simplify asynchronous and concurrent programming in Scala. The main constructs, async and await, are inspired by similar constructs introduced in C{\#} 5.0. The main purpose of async/await is to make it possible to express efficient asynchronous code in a familiar direct style (where suspending operations look as if they were blocking). As a result, non-blocking code using Scala's futures API [1] can be expressed without using higher-order functions, such as map and flatMap, or low-level callbacks.},
author = {Haller, Philipp and Zaugg, Jason},
keywords = {async,asyncawait,await,canonical,scala},
mendeley-tags = {async,asyncawait,await,canonical,scala},
title = {{SIP-22 - Async - Scala Documentation}},
url = {http://docs.scala-lang.org/sips/pending/async.html},
urldate = {2017-09-22},
year = {2016}
}
@inproceedings{Dunkels2006,
abstract = {Event-driven programming is a popular model for writing programs for tiny embedded systems and sensor network nodes. While event-driven programming can keep the memory overhead down, it enforces a state machine programming style which makes many programs difficult to write, maintain, and debug. We present a novel programming abstraction called protothreads that makes it possible to write event-driven programs in a thread-like style, with a memory overhead of only two bytes per protothread. We show that protothreads significantly reduce the complexity of a number of widely used programs previously written with event-driven state machines. For the examined programs the majority of the state machines could be entirely removed. In the other cases the number of states and transitions was drastically decreased. With protothreads the number of lines of code was reduced by one third. The execution time overhead of protothreads is on the order of a few processor cycles.},
address = {New York, New York, USA},
author = {Dunkels, Adam and Schmidt, Oliver and Voigt, Thiemo and Ali, Muneeb},
booktitle = {Proceedings of the 4th International Conference on Embedded Networked Sensor Systems},
doi = {10.1145/1182807.1182811},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Dunkels et al. - 2006 - Protothreads Simplifying Event-driven Programming of Memory-constrained Embedded Systems.pdf:pdf},
isbn = {1595933433},
keywords = {LVL0,LVL1,Protothreads,embedded systems,threads,wireless sensor networks},
mendeley-tags = {LVL0,LVL1,Protothreads},
pages = {29----42},
publisher = {ACM Press},
title = {{Protothreads: Simplifying Event-driven Programming of Memory-constrained Embedded Systems}},
url = {http://portal.acm.org/citation.cfm?doid=1182807.1182811},
year = {2006}
}
@misc{Tismer2018,
abstract = {Stackless Python is an enhanced version of the Python programming language. It allows programmers to reap the benefits of thread-based programming without the performance and complexity problems associated with conventional threads. The microthreads that Stackless adds to Python are a cheap and lightweight convenience which can if used properly, give the following benefits: Improved program structure. More readable code. Increased programmer productivity.},
author = {Tismer, Christian},
title = {{About Stackless}},
url = {https://github.com/stackless-dev/stackless/wiki},
urldate = {2018-09-04},
year = {2018}
}
@misc{Tatham2000,
author = {Tatham, Simon},
isbn = {0201896834},
publisher = {Addison-Wesley},
title = {{Coroutines in C}},
url = {https://www.chiark.greenend.org.uk/{~}sgtatham/coroutines.html},
urldate = {2017-06-19},
year = {2000}
}
@misc{Mittelette2015,
abstract = {We continue to work on resumable functions, here it is a brief update on coroutines status in VS 2015 Update 1. See the Visual Studio 2015 Update1 post here.},
author = {Mittelette, Eric},
title = {{Coroutines in Visual Studio 2015 – Update 1 - Visual C++ Team Blog}},
url = {https://blogs.msdn.microsoft.com/vcblog/2015/11/30/coroutines-in-visual-studio-2015-update-1/},
urldate = {2018-02-04},
year = {2015}
}
@inproceedings{Gay2003,
abstract = {We present nesC, a programming language for networked embedded systems that represent a new design space for application developers. An example of a networked embedded system is a sensor network, which consists of (potentially) thousands of tiny, low-power "motes," each of which execute concurrent, reactive programs that must operate with severe memory and power constraints.nesC's contribution is to support the special needs of this domain by exposing a programming model that incorporates event-driven execution, a flexible concurrency model, and component-oriented application design. Restrictions on the programming model allow the nesC compiler to perform whole-program analyses, including data-race detection (which improves reliability) and aggressive function inlining (which reduces resource consumption).nesC has been used to implement TinyOS, a small operating system for sensor networks, as well as several significant sensor applications. nesC and TinyOS have been adopted by a large number of sensor network research groups, and our experience and evaluation of the language shows that it is effective at supporting the complex, concurrent programming style demanded by this new class of deeply networked systems.},
address = {New York, New York, USA},
author = {Gay, David and Levis, Philip and von Behren, Robert and Welsh, Matt and Brewer, Eric and Culler, David},
booktitle = {Proceedings of the ACM SIGPLAN 2003 conference on Programming language design and implementation - PLDI '03},
doi = {10.1145/781131.781133},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Gay et al. - 2003 - The nesC Language A Holistic Approach to Networked Embedded Systems.pdf:pdf},
isbn = {1581136625},
issn = {03621340},
keywords = {C,LVL2,TinyOS,components,concurrency,data races,first-order,modules,nesC,programming languages},
mendeley-tags = {LVL2},
pages = {1----11},
publisher = {ACM Press},
title = {{The nesC Language: A Holistic Approach to Networked Embedded Systems}},
url = {http://portal.acm.org/citation.cfm?doid=781131.781133},
year = {2003}
}
@article{Sicari2015,
abstract = {Internet of Things (IoT) is characterized by heterogeneous technologies, which concur to the provisioning of innovative services in various application domains. In this scenario, the satisfaction of security and privacy requirements plays a fundamental role. Such requirements include data confidentiality and authentication, access control within the IoT network, privacy and trust among users and things, and the enforcement of security and privacy policies. Traditional security countermeasures cannot be directly applied to IoT technologies due to the different standards and communication stacks involved. Moreover, the high number of interconnected devices arises scalability issues; therefore a flexible infrastructure is needed able to deal with security threats in such a dynamic environment. In this survey we present the main research challenges and the existing solutions in the field of IoT security, identifying open issues, and suggesting some hints for future research.},
archivePrefix = {arXiv},
arxivId = {1404.7799},
author = {Sicari, S. and Rizzardi, A. and Grieco, L.A. and Coen-Porisini, A.},
doi = {10.1016/j.comnet.2014.11.008},
eprint = {1404.7799},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Sicari et al. - 2015 - Security, privacy and trust in Internet of Things The road ahead.pdf:pdf},
isbn = {1389-1286},
issn = {13891286},
journal = {Computer Networks},
keywords = {Internet of Things,IoT,Privacy,Review,Security,Survey,Trust},
mendeley-tags = {IoT,Review,Security,Survey},
month = {jan},
pages = {146--164},
pmid = {18926558},
publisher = {Elsevier B.V.},
title = {{Security, privacy and trust in Internet of Things: The road ahead}},
url = {http://dx.doi.org/10.1016/j.comnet.2014.11.008 http://linkinghub.elsevier.com/retrieve/pii/S1389128614003971},
volume = {76},
year = {2015}
}
@article{Kitchenham2011a,
abstract = {Context: We are strong advocates of evidence-based software engineering (EBSE) in general and systematic literature reviews (SLRs) in particular. We believe it is essential that the SLR methodology is used constructively to support software engineering research. Objective: This study aims to assess the value of mapping studies which are a form of SLR that aims to identify and categorise the available research on a broad software engineering topic. Method: We used a multi-case, participant-observer case study using five examples of studies that were based on preceding mapping studies. We also validated our results by contacting two other researchers who had undertaken studies based on preceding mapping studies and by assessing review comments related to our follow-on studies. Results: Our original case study identified 11 unique benefits that can accrue from basing research on a preceding mapping study of which only two were case specific. We also identified nine problems associated with using preceding mapping studies of which two were case specific. These results were consistent with the information obtained from the validation activities. We did not find an example of an independent research group making use of a mapping study produced by other researchers. Conclusion: Mapping studies can save time and effort for researchers and provide baselines to assist new research efforts. However, they must be of high quality in terms of completeness and rigour if they are to be a reliable basis for follow-on research. {\textcopyright} 2010 Elsevier B.V. All rights reserved.},
author = {Kitchenham, Barbara A. and Budgen, David and {Pearl Brereton}, O.},
doi = {10.1016/j.infsof.2010.12.011},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kitchenham, Budgen, Pearl Brereton - 2011 - Using mapping studies as the basis for further research - A participant-observer case study.pdf:pdf},
isbn = {0950-5849},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Case study,Mapping studies,Software engineering,Systematic literature review},
number = {6},
pages = {638--651},
publisher = {Elsevier B.V.},
title = {{Using mapping studies as the basis for further research - A participant-observer case study}},
url = {http://dx.doi.org/10.1016/j.infsof.2010.12.011},
volume = {53},
year = {2011}
}
@misc{Ogden2012,
author = {Ogden, Max},
keywords = {Callback hell},
mendeley-tags = {Callback hell},
title = {{Callback Hell}},
url = {http://callbackhell.com/},
urldate = {2017-11-18},
year = {2012}
}
@inproceedings{Petersen2008,
abstract = {BACKGROUND: A software engineering systematic map is a defined method to build a classification scheme and structure a software engineering field of interest. The analysis of results focuses on frequencies of publications for categories within the scheme. Thereby, the coverage of the research field can be determined. Different facets of the scheme can also be combined to answer more specific research questions. OBJECTIVE: We describe how to conduct a systematic mapping study in software engineering and provide guidelines. We also compare systematic maps and systematic reviews to clarify how to chose between them. This comparison leads to a set of guidelines for systematic maps. METHOD: We have defined a systematic mapping process and applied it to complete a systematic mapping study. Furthermore, we compare systematic maps with systematic reviews by systematically analyzing existing systematic reviews. RESULTS: We describe a process for software engineering systematic mapping studies and compare it to systematic reviews. Based on this, guidelines for doing systematic maps are defined. CONCLUSIONS: Systematic maps and reviews are different in terms of goals, breadth, validity issues and implications. Thus, they should be used complementarily and require different methods (e.g., for analysis).},
annote = {[1] Kai Petersen, Robert Feldt, Shahid Mujtaba, and Michael Mattsson. 2008. Systematic Mapping Studies in Software Engineering. In Proceedings of the 12th International Conference on Evaluation and Assessment in Software Engineering, 68--77. Retrieved from http://dl.acm.org/citation.cfm?id=2227115.2227123},
author = {Petersen, Kai and Feldt, Robert and Mujtaba, Shahid and Mattsson, Michael},
booktitle = {Proceedings of the 12th International Conference on Evaluation and Assessment in Software Engineering},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Petersen et al. - 2008 - Systematic Mapping Studies in Software Engineering.pdf:pdf},
number = {June},
pages = {68----77},
publisher = {BCS Learning {\&} Development Ltd.},
title = {{Systematic Mapping Studies in Software Engineering}},
year = {2008}
}
@techreport{Kitchenham2004,
abstract = {The objective of this report is to propose a guideline for systematic reviews appropriate for software engineering researchers, including PhD students. A systematic review is a means of evaluating and interpreting all available research relevant to a particular research question, topic area, or phenomenon of interest. Systematic reviews aim to present a fair evaluation of a research topic by using a trustworthy, rigorous, and auditable methodology. The guideline presented in this report was derived from three existing guidelines used by medical researchers. The guideline has been adapted to reflect the specific problems of software engineering research. The guideline covers three phases of a systematic review: planning the review, conducting the review and reporting the review. It is at a relatively high level. It does not consider the impact of question type on the review procedures, nor does it specify in detail mechanisms needed to undertake meta-analysis.},
author = {Kitchenham, Barbara},
booktitle = {Keele, UK, Keele University},
doi = {10.1.1.122.3308},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kitchenham - 2004 - Procedures for performing systematic reviews.pdf:pdf},
isbn = {1353-7776},
issn = {13537776},
keywords = {LVL3},
mendeley-tags = {LVL3},
number = {TR/SE-0401},
pages = {28},
pmid = {15046037},
title = {{Procedures for performing systematic reviews}},
url = {http://csnotes.upm.edu.my/kelasmaya/pgkm20910.nsf/0/715071a8011d4c2f482577a700386d3a/{\$}FILE/10.1.1.122.3308[1].pdf{\%}5Cnhttp://tests-zingarelli.googlecode.com/svn-history/r336/trunk/2-Disciplinas/MetodPesquisa/kitchenham{\_}2004.pdf},
volume = {33},
year = {2004}
}
@misc{Duff88,
abstract = {Reproduction of 1984 netnews note},
author = {Duff, Tom},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Duff - 1988 - Duff's Device.txt:txt},
title = {{Duff's Device}},
url = {https://groups.google.com/forum/{\#}!original/comp.lang.c/sWJtHn6sVps/ESTEdYEpeLsJ},
urldate = {2017-06-19},
year = {1988}
}
@misc{Skerrett2017,
abstract = {For the last 3 years we have been tracking the trends of the IoT developer community through the IoT Developer Survey [2015] [2016]. Today, we released the third edition of the IoT Developer Survey 2017. As in previous years, the report provides some interesting insights into what IoT developers are thinking and using to build IoT solutions. Below are some of the key trends we identified in the results. The survey is the results of a collaboration between the Eclipse IoT Working Group, IEEE, Agile-IoT EU and the IoT Council. Each partner promoted the survey to their respective communities. A total of 713 individuals participated in the survey. The complete report is available for everyone and we also make available the detailed data [xls, odf].},
author = {Skerrett, Ian},
keywords = {RTOS},
mendeley-tags = {RTOS},
title = {{IoT Developer Trends 2017 Edition}},
url = {https://ianskerrett.wordpress.com/2017/04/19/iot-developer-trends-2017-edition/},
urldate = {2017-05-12},
year = {2017}
}
@article{Brereton2007,
abstract = {A consequence of the growing number of empirical studies in software engineering is the need to adopt systematic approaches to assessing and aggregating research outcomes in order to provide a balanced and objective summary of research evidence for a particular topic. The paper reports experiences with applying one such approach, the practice of systematic literature review, to the published studies relevant to topics within the software engineering domain. The systematic literature review process is summarised, a number of reviews being undertaken by the authors and others are described and some lessons about the applicability of this practice to software engineering are extracted. The basic systematic literature review process seems appropriate to software engineering and the preparation and validation of a review protocol in advance of a review activity is especially valuable. The paper highlights areas where some adaptation of the process to accommodate the domain-specific characteristics of software engineering is needed as well as areas where improvements to current software engineering infrastructure and practices would enhance its applicability. In particular, infrastructure support provided by software engineering indexing databases is inadequate. Also, the quality of abstracts is poor; it is usually not possible to judge the relevance of a study from a review of the abstract alone. ?? 2006 Elsevier Inc. All rights reserved.},
author = {Brereton, Pearl and Kitchenham, Barbara A. and Budgen, David and Turner, Mark and Khalil, Mohamed},
doi = {10.1016/j.jss.2006.07.009},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Brereton et al. - 2007 - Lessons from applying the systematic literature review process within the software engineering domain.pdf:pdf},
isbn = {0164-1212},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Empirical software engineering,Systematic literature review},
number = {4},
pages = {571--583},
publisher = {Elsevier Inc.},
title = {{Lessons from applying the systematic literature review process within the software engineering domain}},
url = {http://dx.doi.org/10.1016/j.jss.2006.07.009 http://www.sciencedirect.com/science/article/pii/S016412120600197X},
volume = {80},
year = {2007}
}
@article{Levis2002,
abstract = {OBJECTIVE: To modify the traditional heuristic evaluation method of assessing software usability so that it can be applied to medical devices and used to evaluate the patient safety of those devices through the identification and assessment of usability problems. DESIGN: Heuristic evaluation, a usability inspection method commonly used for software usability evaluation, was modified and extended for medical devices. The modified method was used to evaluate and compare the patient safety of two 1-channel volumetric infusion pumps. RESULTS: The modified heuristic evaluation method was successfully applied to medical devices. One hundred and ninety-two heuristic violations were categorized for 89 usability problems identified for Pump 1, and 121 heuristic violations were categorized for the 52 usability problems identified for Pump 2. Pump 1 had more usability problems with high severity ratings than Pump 2. In general, Pump 1 was found to have more usability issues that are likely to induce more medical errors. CONCLUSIONS: Heuristic evaluation, when modified for medical devices, is a useful, efficient, and low cost method for evaluating patient safety features of medical devices through the identification of usability problems and their severities},
author = {Levis, Philip and Culler, David},
doi = {10.1145/605397.605407},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Levis, Culler - 2002 - Mate A Tiny Virtual Machine for Sensor Networks.pdf:pdf},
isbn = {1581135742},
issn = {01635964},
journal = {ACM SIGPLAN Notices},
keywords = {LVL1},
mendeley-tags = {LVL1},
number = {10},
pages = {85--95},
pmid = {14552844},
title = {{Mate : A Tiny Virtual Machine for Sensor Networks}},
url = {http://www.cs.berkeley.edu/{~}pal/pubs/mate.pdf},
volume = {37},
year = {2002}
}
@inproceedings{Paisley2006,
abstract = {The current practice of physical science research has yielded a continuously growing demand for interconnection network bandwidth to support the sharing of large datasets. Academic research networks and internet service providers have provisioned their networks to handle this type of load, which generates prolonged, high-volume traffic between nodes on the network. Maintenance of QoS for all network users demands that the onset of these (Grid bulk) transfers be detected to enable them to be reengineered through resources specifically provisioned to handle this type of traffic. This paper describes a real-time detector that operates at full-line-rate on Gb/s links, operates at high connection rates, and can track the use of ephemeral or non-standard ports.},
author = {Paisley, Jonathan and Sventek, Joseph},
booktitle = {2006 IEEE/IFIP Network Operations and Management Symposium NOMS 2006},
doi = {10.1109/NOMS.2006.1687539},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Paisley, Sventek - 2006 - Real-time Detection of Grid Bulk Transfer Traffic.pdf:pdf},
keywords = {Bandwidth,Data mining,Detectors,Distributed computing,Geophysics computing,Internet,Internet service providers,LVL4,Multiprotocol label switching,Protocols,Protothreads,QoS,Quality of service,Routing,Telecommunication traffic,grid bulk transfer traffic,interconnection network bandwidth,quality of service,real-time detection,telecommunication traffic},
mendeley-tags = {LVL4,Protothreads},
pages = {66--72},
title = {{Real-time Detection of Grid Bulk Transfer Traffic}},
url = {http://eprints.gla.ac.uk/3671/},
year = {2006}
}
@unpublished{ISO2017,
abstract = {This Technical Specification describes extensions to the C++ Programming Language (Clause 2) that enable definition of coroutines. These extensions include new syntactic forms and modifications to existing language semantics.},
author = {ISO/IEC},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/ISOIEC - 2017 - N4680 Programming Languages - C Extensions for Library Fundamentals.pdf:pdf},
keywords = {Coroutines,ISO},
mendeley-tags = {Coroutines,ISO},
number = {30},
title = {{N4680 Programming Languages - C++ Extensions for Library Fundamentals}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf},
year = {2017}
}
@unpublished{Romer2018,
abstract = {The Coroutines TS provides users with an elegant and efficient abstraction for writing asynchronous code. We mean that as both sincere praise, and as a critique: the Coroutines TS provides an abstraction, but it does not provide programmers with the facilities they need to define their own elegant and efficient abstractions. Furthermore, the TS's abstraction prioritizes the asynchronous use case in a variety of ways, which prevents it from being general-purpose. It gives programmers ways of extending and reusing the asynchrony abstraction, but they remain locked into many of the design tradeoffs motivated by the original use case. Fundamentally, the Coroutines TS does not provide a direct and efficient model of hardware1: the primitive objects and operations that are used to implement coroutines are hidden behind an abstraction boundary.},
author = {Romer, Geoff and Dennett, James and Carruth, Chandler},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Romer, Dennett, Carruth - 2018 - P1063R0 - Core Coroutines Making coroutines simpler, faster, and more general.pdf:pdf},
title = {{P1063R0 - Core Coroutines Making coroutines simpler, faster, and more general}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1063r0.pdf},
year = {2018}
}
@misc{AspenCore2017,
author = {{AspenCore Global Media}},
booktitle = {EE Times},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/AspenCore Global Media - 2017 - 2017 Embedded Markets Study.pdf:pdf},
keywords = {Embedded,Survey},
mendeley-tags = {Embedded,Survey},
number = {April},
title = {{2017 Embedded Markets Study}},
url = {http://m.eet.com/media/1246048/2017-embedded-market-study.pdf},
urldate = {2017-08-29},
year = {2017}
}
@inproceedings{Edwards2009,
abstract = {Side effects are both the essence and bane of imperative programming. The programmer must carefully coordinate actions to manage their side effects upon each other. Such coordination is complex, error-prone, and fragile. Coherent reaction is a new model of change-driven computation that coordinates effects automatically. State changes trigger events called reactions that in turn change other states. A coherent execution order is one in which each reaction executes before any others that are affected by its changes. A coherent order is discovered iteratively by detecting incoherencies as they occur and backtracking their effects. Unlike alternative solutions, much of the power of imperative programming is retained, as is the common sense notion of mutable state. Automatically coordinating actions lets the programmer express what to do, not when to do it. Coherent reactions are embodied in the Coherence language, which is specialized for interactive applications like those common on the desktop and web. The fundamental building block of Coherence is the dynamically typed mutable tree. The fundamental abstraction mechanism is the virtual tree, whose value is lazily computed, and whose behavior is generated by coherent reactions.},
address = {New York, New York, USA},
author = {Edwards, Jonathan},
booktitle = {Proceeding of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications - OOPSLA '09},
doi = {10.1145/1639950.1640058},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Edwards - 2009 - Coherent reaction.pdf:pdf},
isbn = {9781605587684},
keywords = {callback hell},
mendeley-tags = {callback hell},
pages = {925},
publisher = {ACM Press},
title = {{Coherent reaction}},
url = {http://dl.acm.org/citation.cfm?doid=1639950.1640058},
year = {2009}
}
@misc{ECMA2017,
abstract = {Async Function Definitions},
author = {ECMA},
title = {{ECMAScript Latest Draft (ECMA-262) Async Function Definitions}},
url = {https://tc39.github.io/ecma262/{\#}sec-async-function-definitions},
year = {2017}
}
@inproceedings{Meijer2010,
address = {New York, New York, USA},
author = {Meijer, Erik},
booktitle = {ACM SIGPLAN Commercial Users of Functional Programming on - CUFP '10},
doi = {10.1145/1900160.1900173},
isbn = {9781450305167},
pages = {1},
publisher = {ACM Press},
title = {{Reactive extensions (Rx): Curing Your Asynchronous Programming Blues}},
url = {http://portal.acm.org/citation.cfm?doid=1900160.1900173},
year = {2010}
}
@inproceedings{Bierman2012,
abstract = {Writing applications that connect to external services and yet remain responsive and resource conscious is a difficult task. With the rise of web programming this has become a common problem. The solution lies in using asynchronous operations that separate issuing a request from waiting for its completion. However, doing so in common object-oriented languages is difficult and error prone. Asynchronous operations rely on callbacks, forcing the programmer to cede control. This inversion of control-flow impedes the use of structured control constructs, the staple of sequential code. In this paper, we describe the language support for asynchronous programming in the upcoming version of C {\$}{\^{}}\backslashsharp{\$} . The feature enables asynchronous programming using structured control constructs. Our main contribution is a precise mathematical description that is abstract (avoiding descriptions of compiler-generated state machines) and yet sufficiently concrete to allow important implementation properties to be identified and proved correct.},
address = {Berlin, Heidelberg},
author = {Bierman, Gavin and Russo, Claudio and Mainland, Geoffrey and Meijer, Erik and Torgersen, Mads},
booktitle = {ECOOP 2012 -- Object-Oriented Programming},
doi = {10.1007/978-3-642-31057-7_12},
editor = {Noble, James},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Bierman et al. - 2012 - Pause 'n' Play Formalizing Asynchronous C sharp.pdf:pdf},
isbn = {978-3-642-31057-7},
keywords = {LVL1,async,asyncawait,await,csharp},
mendeley-tags = {LVL1,async,asyncawait,await,csharp},
pages = {233--257},
publisher = {Springer Berlin Heidelberg},
title = {{Pause 'n' Play: Formalizing Asynchronous C sharp}},
url = {https://pdfs.semanticscholar.org/cb1c/8e5ff90ecffd438c446595d0056d613669c7.pdf},
year = {2012}
}
@techreport{Kitchenham2007,
abstract = {The objective of this report is to propose comprehensive guidelines for systematic literature reviews appropriate for software engineering researchers, including PhD students. A systematic literature review is a means of evaluating and interpreting all available research relevant to a particular research question, topic area, or phenomenon of interest. Systematic reviews aim to present a fair evaluation of a research topic by using a trustworthy, rigorous, and auditable methodology. The guidelines presented in this report were derived from three existing guidelines used by medical researchers, two books produced by researchers with social science backgrounds and discussions with researchers from other disciplines who are involved in evidence-based practice. The guidelines have been adapted to reflect the specific problems of software engineering research. The guidelines cover three phases of a systematic literature review: planning the review, conducting the review and reporting the review. They provide a relatively high level description. They do not consider the impact of the research questions on the review procedures, nor do they specify in detail the mechanisms needed to perform meta-analysis.},
archivePrefix = {arXiv},
arxivId = {1304.1186},
author = {Kitchenham, Barbara and Charters, Stuart},
booktitle = {Technical Report EBSE-2007-01},
eprint = {1304.1186},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kitchenham, Charters - 2007 - Guidelines for performing Systematic Literature reviews in Software Engineering Version 2.3.pdf:pdf},
isbn = {1595933751},
issn = {00010782},
keywords = {SLR,SMS},
mendeley-tags = {SLR,SMS},
pmid = {10853839},
title = {{Guidelines for performing Systematic Literature reviews in Software Engineering Version 2.3}},
year = {2007}
}
@inproceedings{Kambona2013,
address = {New York, NY, USA},
author = {Kambona, Kennedy and Boix, Elisa Gonzalez and {De Meuter}, Wolfgang},
booktitle = {Proceedings of the 7th Workshop on Dynamic Languages and Applications},
doi = {10.1145/2489798.2489802},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Kambona, Boix, De Meuter - 2013 - An Evaluation of Reactive Programming and Promises for Structuring Collaborative Web Applications.pdf:pdf},
isbn = {978-1-4503-2041-2},
keywords = {Javascript,behaviours,callbacks,event streams,futures,promises,reactive programming},
pages = {3:1----3:9},
publisher = {ACM},
series = {DYLA '13},
title = {{An Evaluation of Reactive Programming and Promises for Structuring Collaborative Web Applications}},
url = {http://doi.acm.org.elibrary.jcu.edu.au/10.1145/2489798.2489802},
year = {2013}
}
@misc{Herity2015,
abstract = {The suspicion lingers that C++ is somehow unsuitable for use in small embedded systems. For 8- and 16-bit processors lacking a C++ compiler, that may be a concern, but there are now 32-bit microcontrollers available for under a dollar supported by mature C++ compilers. As this article series will make clear, with the continued improvements in the language most C++ features have no impact on code size or on speed. Others have a small impact that is generally worth paying for. To use C++ effectively in embedded systems, you need to be aware of what is going on at the machine code level, just as in C. Armed with that knowledge, the embedded systems programmer can produce code that is smaller, faster and safer than is possible without C++.},
author = {Herity, Dominic},
booktitle = {Embedded},
title = {{Modern C++ in embedded systems – Part 1: Myth and Reality | Embedded}},
url = {https://www.embedded.com/design/programming-languages-and-tools/4438660/1/Modern-C--in-embedded-systems---Part-1--Myth-and-Reality},
urldate = {2018-01-24},
year = {2015}
}
@unpublished{VanRossum2005,
author = {van Rossum, Guido and Eby, Phillip J.},
institution = {Python.org},
keywords = {Coroutines,Python},
mendeley-tags = {Coroutines,Python},
title = {{PEP 342 -- Coroutines via Enhanced Generators}},
url = {https://www.python.org/dev/peps/pep-0342/},
year = {2005}
}
@book{Marlin1979,
author = {Marlin, Christopher D},
editor = {Goos, G and Hartmanis, J},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Marlin - 1979 - Coroutines A Programming Methodology, a Language Design and an Implementation.pdf:pdf},
number = {95},
publisher = {Springer, Berlin, Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Coroutines: A Programming Methodology, a Language Design and an Implementation}},
year = {1979}
}
@article{Liskov1988,
abstract = {This paper deals with the integration of an efficient asynchronous remote procedure call mechanism into a programming language. It describes a new data type called a promise that was designed to support asynchronous calls. Promises allow a caller to run in parallel with a call and to pick up the results of the call, including any exceptions it raises, in a convenient and type-safe manner. The paper also discusses efficient composition of sequences of asynchronous calls to different locations in a network.},
author = {Liskov, B. and Shrira, L.},
doi = {10.1145/960116.54016},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Liskov, Shrira - 1988 - Promises linguistic support for efficient asynchronous procedure calls in distributed systems.pdf:pdf},
isbn = {0897912691},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {Asynchronous,Distributed,Promises},
mendeley-tags = {Asynchronous,Distributed,Promises},
number = {7},
pages = {260--267},
title = {{Promises: linguistic support for efficient asynchronous procedure calls in distributed systems}},
url = {http://dl.acm.org/citation.cfm?id=54016},
volume = {23},
year = {1988}
}
@article{Gubbi2013,
abstract = {Ubiquitous sensing enabled by Wireless Sensor Network (WSN) technologies cuts across many areas of modern day living. This offers the ability to measure, infer and understand environmental indicators, from delicate ecologies and natural resources to urban environments. The proliferation of these devices in a communicating-actuating network creates the Internet of Things (IoT), wherein sensors and actuators blend seamlessly with the environment around us, and the information is shared across platforms in order to develop a common operating picture (COP). Fueled by the recent adaptation of a variety of enabling wireless technologies such as RFID tags and embedded sensor and actuator nodes, the IoT has stepped out of its infancy and is the next revolutionary technology in transforming the Internet into a fully integrated Future Internet. As we move from www (static pages web) to web2 (social networking web) to web3 (ubiquitous computing web), the need for data-on-demand using sophisticated intuitive queries increases significantly. This paper presents a Cloud centric vision for worldwide implementation of Internet of Things. The key enabling technologies and application domains that are likely to drive IoT research in the near future are discussed. A Cloud implementation using Aneka, which is based on interaction of private and public Clouds is presented. We conclude our IoT vision by expanding on the need for convergence of WSN, the Internet and distributed computing directed at technological research community. ?? 2013 Elsevier B.V. All rights reserved.},
archivePrefix = {arXiv},
arxivId = {1207.0203},
author = {Gubbi, Jayavardhana and Buyya, Rajkumar and Marusic, Slaven and Palaniswami, Marimuthu},
doi = {10.1016/j.future.2013.01.010},
eprint = {1207.0203},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Gubbi et al. - 2013 - Internet of Things (IoT) A vision, architectural elements, and future directions.pdf:pdf},
isbn = {0167739X},
issn = {0167739X},
journal = {Future Generation Computer Systems},
keywords = {Cloud computing,Internet of Things,LVL1,RFID Smart environments,Ubiquitous sensing,Wireless sensor networks},
mendeley-tags = {LVL1},
number = {7},
pages = {1645--1660},
pmid = {20120930},
publisher = {Elsevier B.V.},
title = {{Internet of Things (IoT): A vision, architectural elements, and future directions}},
url = {http://dx.doi.org/10.1016/j.future.2013.01.010},
volume = {29},
year = {2013}
}
@unpublished{Riegel2015,
abstract = {I have argued in the past that there are commonalities between the different coroutine proposals and that there are opportunities for a unified proposal. This paper is meant to provide more detail about this. So far, the proposals have been presented as separate vertical solutions, and it has been claimed that there is no substantial common ground between them. However, I believe we should be looking for commonalities, or we will both make future extensions of the features presented in these proposals harder and will make all of them harder to learn for programmers. To me, the design of coroutines and resumable functions is not just in the space of programming interfaces. A large part of it is also at the level of the abstract machine: In particular, how we deal with concurrency beyond std::thread? While it's easy for programmers to use std::thread, they often don't need a full-featured operating system thread nor would want one because of additional, unnecessary overhead that might be attached to it; a thread of execution from a thread pool, or something like a coroutine would often be sufficient and better. I believe there is consensus in SG1 that we need more kinds of threads of execution beyond those spawned by std::thread (see, for example, the parallelism TS or P0072R0). The main points I'm arguing for in this paper are: • Executing coroutines, generators, etc. should be understood as representing threads of execution, with certain execution properties. Note that I did not say that they should be OS threads or similar to what std::thread spawns. • Resumable functions enable a certain implementation of threads of execution, in particular how the call stack is implemented. The so-called stackful coroutines use a more traditional stack implementation. • The compiler can bridge the gap between those two stack implementations un-der certain conditions by providing the impression of a stackful implementation (e.g., calling through normal non-resumable functions) but generating code that is using resumable functions internally. The Transactional Memory TS is a prece-dent for very similar compiler support, showing that it can be both specified and implemented 1 . In this paper I will not discuss interfaces of programming abstractions. Personally, I am more concerned about the design at the conceptual level than about details of a particular interface; my focus is on the internals, both design-wise and how it affects implementations or enables certain ones.},
author = {Riegel, Torvald},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Riegel - 2015 - P0073R0 - On unifying the coroutines and resumable functions proposals.pdf:pdf},
keywords = {ISOCPP},
mendeley-tags = {ISOCPP},
title = {{P0073R0 - On unifying the coroutines and resumable functions proposals}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0073r0.pdf},
year = {2015}
}
@article{Moura2004a,
abstract = {After a period of oblivion, a renewal of interest in coroutines is being observed. However, most current implementations of coroutine mechanisms are restricted, and motivated by particular uses. The convenience of providing true coroutines as a general control abstraction is disregarded. This paper presents and discusses the coroutine facilities provided by the language Lua, a full implementation of the concept of asymmetric coroutines. It also shows that this powerful construct supports easy and succint implementations of useful control behaviors.},
author = {Moura, Ana L{\'{u}}cia De and Rodriguez, Noemi and Ierusalimschy, Roberto},
doi = {10.3217/jucs-010-07-0910},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Moura, Rodriguez, Ierusalimschy - 2004 - Coroutines in Lua.pdf:pdf},
issn = {0958695X},
journal = {Journal of Universal Computer Science},
keywords = {Coroutine,LVL9,Lua,control structures,coroutines,generators,lua language},
mendeley-tags = {Coroutine,LVL9,Lua},
number = {7},
pages = {910--925},
title = {{Coroutines in Lua}},
url = {http://www.jucs.org/jucs{\_}10{\_}7/coroutines{\_}in{\_}lua/de{\_}moura{\_}a{\_}l.pdf},
volume = {10},
year = {2004}
}
@misc{George2014b,
abstract = {There is a multitude of modules and boards from different sources which carry the ESP8266 chip. MicroPython tries to provide a generic port which would run on as many boards/modules as possible, but there may be limitations. Adafruit Feather HUZZAH board is taken as a reference board for the port (for example, testing is performed on it). If you have another board, please make sure you have a datasheet, schematics and other reference materials for your board handy to look up various aspects of your board functioning.},
author = {George, Damien P. and Sokolovsky, Paul},
keywords = {ESP8266,Micropython},
mendeley-tags = {ESP8266,Micropython},
title = {{General information about the ESP8266 port — MicroPython 1.9.4 documentation}},
url = {http://docs.micropython.org/en/latest/esp8266/esp8266/general.html},
urldate = {2018-09-04},
year = {2014}
}
@article{Knuth1968,
author = {Knuth, Donald E},
publisher = {Addison Wesley Longman Publishing Co., Inc.},
title = {{The Art of Computer Programming, Vol. 1: Fundamental Algorithms (3rd. ed.)}},
year = {1997}
}
@inproceedings{Dunkels2004,
abstract = {Wireless sensor networks are composed of large numbers of tiny networked devices that communicate untethered. For large scale networks, it is important to be able to download code into the network dynamically. We present Contiki, a lightweight operating system with support for dynamic loading and replacement of individual programs and services. Contiki is built around an event-driven kernel but provides optional preemptive multithreading that can be applied to individual processes. We show that dynamic loading and unloading is feasible in a resource constrained environment, while keeping the base system lightweight and compact.},
author = {Dunkels, A. and Gronvall, B. and Voigt, T.},
booktitle = {29th Annual IEEE International Conference on Local Computer Networks},
doi = {10.1109/LCN.2004.38},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Dunkels, Gronvall, Voigt - 2004 - Contiki - a lightweight and flexible operating system for tiny networked sensors.pdf:pdf},
isbn = {0-7695-2260-2},
keywords = {Contiki,LVL1,RTOS},
mendeley-tags = {Contiki,LVL1,RTOS},
pages = {455--462},
publisher = {IEEE (Comput. Soc.)},
title = {{Contiki - a lightweight and flexible operating system for tiny networked sensors}},
url = {http://ieeexplore.ieee.org/document/1367266/},
year = {2004}
}
@techreport{Goodspeed2014,
abstract = {At Rapperswil in June 2014, Nat Goodspeed and Oliver Kowalke brought to SG1 a proposal to add coroutines to C++i . Niklas Gustafsson brought a proposal to add resumable functions to C++ii. We were directed by SG1 to place these proposals within a single conceptual space so as to unify them to the extent possible. Nat, Oliver, Niklas and Torvald Riegel discussed this conceptual space at length at Rapperswil. Nat and Gor Nishanov pursued the discussion further in Redmond. This paper is an attempt to respond to the committee's request.},
author = {Goodspeed, Nat},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Goodspeed - 2014 - Stackful Coroutines and Stackless Resumable Functions.pdf:pdf},
keywords = {ISOCPP},
mendeley-tags = {ISOCPP},
title = {{Stackful Coroutines and Stackless Resumable Functions}},
url = {http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4232.pdf},
year = {2014}
}
@inproceedings{Brodu2015,
abstract = {Javascript is the prevalent scripting language for the web. It lets web pages register callbacks to react to user events. A callback is a function to be invoked later with a result currently unavailable. This pattern also proved to respond efficiently to remote requests. Javascript is currently used to implement complete web applications. However, callbacks are ill-suited to arrange a large asynchronous execution flow. Promises are a more adapted alternative. They provide a unified control over both the synchronous and asynchronous execution flows. The next version of Javascript proposes to replace callbacks with Promises. This paper brings the first step toward a compiler to help developers prepare this shift. We present an equivalence between callbacks and Dues. The latter are a simpler specification of Promises developed for the purpose of this demonstration. From this equivalence, we implement a compiler to transform an imbrication of callbacks into a chain of Dues. This equivalence is limited to Node.js-style asynchronous callbacks declared in situ. We evaluate our compiler over 64 npm packages, 9 of them present compatible callbacks and compile successfully. We consider this shift to be a first step toward the merge of concepts from the data-flow programming model into the imperative programming model.},
address = {New York, New York, USA},
author = {Brodu, Etienne and Fr{\'{e}}not, St{\'{e}}phane and Obl{\'{e}}, Fr{\'{e}}d{\'{e}}ric},
booktitle = {Proceedings of the 1st Workshop on All-Web Real-Time Systems - AWeS '15},
doi = {10.1145/2749215.2749216},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Brodu, Fr{\'{e}}not, Obl{\'{e}} - 2015 - Toward Automatic Update from Callbacks to Promises.pdf:pdf},
isbn = {9781450334778},
keywords = {Javascript,LVL1,await,compilation,flow programming,web},
mendeley-tags = {LVL1,await},
pages = {1--8},
publisher = {ACM Press},
title = {{Toward Automatic Update from Callbacks to Promises}},
url = {http://dl.acm.org/citation.cfm?doid=2749215.2749216},
year = {2015}
}
@misc{Python2017,
author = {{The Python Software Foundation}},
title = {{9. Classes — Python 3.6.4 documentation}},
url = {https://docs.python.org/3/tutorial/classes.html{\#}generators},
urldate = {2018-01-31},
year = {2018}
}
@misc{VanderMeulen2017,
abstract = {Gartner, Inc. forecasts that 8.4 billion connected things will be in use worldwide in 2017, up 31 percent from 2016, and will reach 20.4 billion by 2020. Total spending on endpoints and services will reach almost {\$}2 trillion in 2017.},
author = {van der Meulen, Rob},
booktitle = {Press releases},
keywords = {IoT,Prediction},
mendeley-tags = {IoT,Prediction},
title = {{Gartner Says 8.4 Billion Connected "Things" Will Be in Use in 2017, Up 31 Percent From 2016}},
url = {http://www.gartner.com/newsroom/id/3598917},
urldate = {2017-08-15},
year = {2017}
}
@misc{Dunkels2005b,
abstract = {Protothreads are a extremely lightweight, stackless threads that provides a blocking context on top of an event-driven system, without the overhead of per-thread stacks. The purpose of protothreads is to implement sequential flow of control without using complex state machines or full multi-threading. Protothreads provides conditional blocking inside a C function.},
author = {Dunkels, Adam},
keywords = {Protothreads},
mendeley-tags = {Protothreads},
title = {{About protothreads}},
url = {http://dunkels.com/adam/pt/about.html},
urldate = {2018-01-31},
year = {2005}
}
@misc{Barry2018,
abstract = {Developed in partnership with the world's leading chip companies over a 14 year period, the FreeRTOS kernel is a market leading real time operating system (or RTOS), and the de-facto standard solution for microcontrollers and small microprocessors.},
author = {Barry, Richard},
keywords = {FreeRTOS},
mendeley-tags = {FreeRTOS},
title = {{The FreeRTOS Kernel}},
url = {https://www.freertos.org/},
urldate = {2018-02-02},
year = {2018}
}
@article{Al-Fuqaha2015,
abstract = {This paper provides an overview of the Internet of Things (IoT) with emphasis on enabling technologies, protocols and application issues. The IoT is enabled by the latest developments in RFID, smart sensors, communication technologies and Internet protocols. The basic premise is to have smart sensors collaborate directly without human involvement to deliver a new class of applications. The current revolution in Internet, mobile and machine-to-machine (M2M) technologies can be seen as the first phase of the IoT. In the coming years, the IoT is expected to bridge diverse technologies to enable new applications by connecting physical objects together in support of intelligent decision making. This paper starts by providing a horizontal overview of the IoT. Then, we give an overview of some technical details that pertain to the IoT enabling technologies, protocols and applications. Compared to other survey papers in the field, our objective is to provide a more thorough summary of the most relevant protocols and application issues to enable researchers and application developers to get up to speed quickly on how the different protocols fit together to deliver desired functionalities without having to go through RFCs and the standards specifications. We also provide an overview of some of the key IoT challenges presented in the recent literature and provide a summary of related research work. Moreover, we explore the relation between the IoT and other emerging technologies including big data analytics and cloud and fog computing. We also present the need for better horizontal integration among IoT services. Finally, we present detailed service use-cases to illustrate how the different protocols presented in the paper fit together to deliver desired IoT services.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Al-Fuqaha, Ala and Guizani, Mohsen and Mohammadi, Mehdi and Aledhari, Mohammed and Ayyash, Moussa},
doi = {10.1109/COMST.2015.2444095},
eprint = {arXiv:1011.1669v3},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Al-Fuqaha et al. - 2015 - Internet of Things A Survey on Enabling Technologies, Protocols, and Applications.pdf:pdf},
isbn = {1553-877X},
issn = {1553877X},
journal = {IEEE Communications Surveys and Tutorials},
keywords = {AMQP,CoAP,DDS,Internet of Things (IoT),IoT gateway,LVL2,MQTT,XMPP,mDNS},
mendeley-tags = {LVL2},
number = {4},
pages = {2347--2376},
pmid = {15487673},
title = {{Internet of Things: A Survey on Enabling Technologies, Protocols, and Applications}},
volume = {17},
year = {2015}
}
@misc{George2014a,
abstract = {MicroPython is a lean and efficient implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimised to run on microcontrollers and in constrained environments.},
author = {George, Damien},
keywords = {Micropython},
mendeley-tags = {Micropython},
title = {{MicroPython - Python for microcontrollers}},
url = {http://micropython.org/},
urldate = {2017-07-31},
year = {2014}
}
@article{Manyika2015,
abstract = {By blending physical and digital realms, the Internet of Things (IoT) vastly expands the reach of information technology. The myriad possibilities that arise from the ability to monitor and control things in the physical world electronically have inspired a surge of innovation and enthusiasm. The sweeping changes that IoT can bring to how companies manage physical assets, how consumers attend to their health and fitness, and how cities operate have also inspired visions of a very different future, as well as a good deal of hype. McKinsey has been involved in the Internet of Things over the years and we have seen how rapid advances in technology and know-how have exceeded our expectations—and yet how difficult it will be to obtain the greatest benefits of IoT implementations, which require creating highly complex systems and coordinating technology, investment, and talent across both space and time.},
author = {Manyika, James and Chui, Michael and Bisson, Peter and Woetzel, Jonathan and Dobbs, Richard and Bughin, Jacques and Aharon, Dan},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Manyika et al. - 2015 - The Internet of Things Mapping the value beyond the hype.pdf:pdf},
isbn = {978-3-319-05028-7},
issn = {1860949X},
journal = {McKinsey Global Institute},
number = {June},
pages = {144},
title = {{The Internet of Things: Mapping the value beyond the hype}},
url = {https://www.mckinsey.com/{~}/media/McKinsey/Business Functions/McKinsey Digital/Our Insights/The Internet of Things The value of digitizing the physical world/The-Internet-of-things-Mapping-the-value-beyond-the-hype.ashx},
year = {2015}
}
@article{Goldthwaite2006,
author = {Goldthwaite, Lois},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage//IsoIec - 2006 - Technical Report on C Performance.pdf:pdf},
journal = {ISO/IEC PDTR},
title = {{Technical report on C++ performance}},
volume = {18015},
year = {2006}
}
@article{Hempel2008,
author = {Hempel, Ralph},
chapter = {26},
isbn = {8590379841},
journal = {Lua Programming Gems},
keywords = {Lua},
mendeley-tags = {Lua},
publisher = {Lua.org},
title = {{Porting Lua to a microcontroller}},
year = {2008}
}
@inbook{Levis2005,
abstract = {We present TinyOS, a flexible, application-specific operating system for sensor networks, which form a core component of ambient intelligence systems. Sensor networks consist of (potentially) thousands of tiny, low-power nodes, each of which execute concurrent, reactive programs that must operate with severe memory and power constraints. The sensor network challenges of limited resources, event-centric concurrent applications, and low-power operation drive the design of TinyOS. Our solution combines flexible, fine-grain components with an execution model that supports complex yet safe concurrent operations. TinyOS meets these challenges well and has become the platform of choice for sensor network research; it is in use by over a hundred groups worldwide, and supports a broad range of applications and research topics. We provide a qualitative and quantitative evaluation of the system, showing that it supports complex, concurrent programs with very low memory requirements (many applications fit within 16KB of memory, and the core OS is 400 bytes) and efficient, low-power operation.We present our experiences with TinyOS as a platform for sensor network innovation and applications.},
address = {Berlin, Heidelberg},
author = {Levis, P and Madden, S and Polastre, J and Szewczyk, R and Whitehouse, K and Woo, A and Gay, D and Hill, J and Welsh, M and Brewer, E and Culler, D},
booktitle = {Ambient Intelligence},
doi = {10.1007/3-540-27139-2_7},
editor = {Weber, Werner and Rabaey, Jan M and Aarts, Emile},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Levis et al. - 2005 - TinyOS An Operating System for Sensor Networks.pdf:pdf},
isbn = {978-3-540-27139-0},
pages = {115--148},
publisher = {Springer Berlin Heidelberg},
title = {{TinyOS: An Operating System for Sensor Networks}},
url = {https://doi.org/10.1007/3-540-27139-2{\_}7},
year = {2005}
}
@article{Weber2015,
abstract = {A B S T R A C T The Internet of Things presents unique challenges to the protection of individual privacy. This article highlights the growing need for appropriate regulatory as well as technical action in order to bridge the gap between the automated surveillance by IoT devices and the rights of individuals who are often unaware of the potential privacy risk to which they are exposed. As a result, new legal approaches for the protection of privacy need to be developed.},
annote = {http://ac.els-cdn.com.elibrary.jcu.edu.au/S0267364915001156/1-s2.0-S0267364915001156-main.pdf?{\_}tid=5717bede-111d-11e7-9589-00000aab0f01{\&}acdnat=1490420517{\_}138a4d7485a7e9042941b11b5eeecf4e},
author = {Weber, Rolf H},
doi = {10.1016/j.clsr.2015.07.002},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Weber - 2015 - Internet of things Privacy issues revisited.pdf:pdf},
journal = {Computer Law {\&} Security Review: The International Journal of Technology Law and Practice},
keywords = {Data minimization,Internet of things,LVL2,Privacy,Privacy challenges,Privacy enhancing technologies,Quality of data,Security,Transparency},
mendeley-tags = {LVL2,Privacy,Security},
pages = {618--627},
title = {{Internet of things: Privacy issues revisited}},
volume = {31},
year = {2015}
}
@inproceedings{Okur2014,
address = {New York, New York, USA},
author = {Okur, Semih and Hartveld, David L. and Dig, Danny and van Deursen, Arie},
booktitle = {Proceedings of the 36th International Conference on Software Engineering - ICSE 2014},
doi = {10.1145/2568225.2568309},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Okur et al. - 2014 - A Study and Toolkit for Asynchronous Programming in C{\#}.pdf:pdf},
isbn = {9781450327565},
keywords = {C{\#},LVL1,Program transformation,asynchronous},
mendeley-tags = {LVL1},
pages = {1117--1127},
publisher = {ACM Press},
title = {{A Study and Toolkit for Asynchronous Programming in C{\#}}},
url = {http://dl.acm.org/citation.cfm?doid=2568225.2568309},
year = {2014}
}
@article{Dunkels2005,
abstract = {Wireless sensor networks consist of tiny devices that usually have severe resource constraints in terms of energy, process-ing power and memory. In order to work efficiently within the constrained memory, many operating systems for such devices are based on an event-driven model rather than on multi-threading. While event-driven systems allow for re-duced memory usage, they require programs to be developed as explicit state machines. Since implementing programs as explicit state machines is hard, developing, maintaining, and debugging programs for event-driven systems is difficult. In this paper, we introduce protothreads, a programming abstraction for event-driven sensor network systems. Pro-tothreads simplify implementation of high-level functional-ity on top of event-driven systems, without significantly in-creasing the memory requirements. The memory require-ment of a protothread is that of an unsigned integer.},
author = {Dunkels, Adam and Schmidt, Oliver and Voigt, Thiemo},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Dunkels, Schmidt, Voigt - 2005 - Using protothreads for sensor node programming.pdf:pdf},
journal = {Proceedings of the REALWSN},
keywords = {Contiki,LVL1,Protothreads},
mendeley-tags = {Contiki,LVL1,Protothreads},
title = {{Using protothreads for sensor node programming}},
url = {http://www.dunkels.com/adam/dunkels05using.pdf},
year = {2005}
}
@article{Petersen2015,
abstract = {Context Systematic mapping studies are used to structure a research area, while systematic reviews are focused on gathering and synthesizing evidence. The most recent guidelines for systematic mapping are from 2008. Since that time, many suggestions have been made of how to improve systematic literature reviews (SLRs). There is a need to evaluate how researchers conduct the process of systematic mapping and identify how the guidelines should be updated based on the lessons learned from the existing systematic maps and SLR guidelines. Objective To identify how the systematic mapping process is conducted (including search, study selection, analysis and presentation of data, etc.); to identify improvement potentials in conducting the systematic mapping process and updating the guidelines accordingly. Method We conducted a systematic mapping study of systematic maps, considering some practices of systematic review guidelines as well (in particular in relation to defining the search and to conduct a quality assessment). Results In a large number of studies multiple guidelines are used and combined, which leads to different ways in conducting mapping studies. The reason for combining guidelines was that they differed in the recommendations given. Conclusion The most frequently followed guidelines are not sufficient alone. Hence, there was a need to provide an update of how to conduct systematic mapping studies. New guidelines have been proposed consolidating existing findings.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Petersen, Kai and Vakkalanka, Sairam and Kuzniarz, Ludwik},
doi = {10.1016/j.infsof.2015.03.007},
eprint = {arXiv:1011.1669v3},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Petersen, Vakkalanka, Kuzniarz - 2015 - Guidelines for conducting systematic mapping studies in software engineering An update.pdf:pdf},
isbn = {0360-1315},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Guidelines,Review,SLR,Software engineering,Systematic mapping studies},
mendeley-tags = {Review,SLR},
pages = {1--18},
pmid = {25246403},
publisher = {Elsevier B.V.},
title = {{Guidelines for conducting systematic mapping studies in software engineering: An update}},
url = {http://dx.doi.org/10.1016/j.infsof.2015.03.007},
volume = {64},
year = {2015}
}
@article{Atzori2010,
abstract = {This paper addresses the Internet of Things. Main enabling factor of this promising paradigm is the integration of several technologies and communications solutions. Identification and tracking technologies, wired and wireless sensor and actuator networks, enhanced communication protocols (shared with the Next Generation Internet), and distributed intelligence for smart objects are just the most relevant. As one can easily imagine, any serious contribution to the advance of the Internet of Things must necessarily be the result of synergetic activities conducted in different fields of knowledge, such as telecommunications, informatics, electronics and social science. In such a complex scenario, this survey is directed to those who want to approach this complex discipline and contribute to its development. Different visions of this Internet of Things paradigm are reported and enabling technologies reviewed. What emerges is that still major issues shall be faced by the research community. The most relevant among them are addressed in details.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Atzori, Luigi and Iera, Antonio and Morabito, Giacomo},
doi = {10.1016/j.comnet.2010.05.010},
eprint = {arXiv:1011.1669v3},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Atzori, Iera, Morabito - 2010 - The Internet of Things A survey.pdf:pdf},
isbn = {1389-1286},
issn = {13891286},
journal = {Computer Networks},
keywords = {Internet of Things,LVL1,Pervasive computing,RFID systems},
mendeley-tags = {LVL1},
number = {15},
pages = {2787--2805},
pmid = {25246403},
publisher = {Elsevier B.V.},
title = {{The Internet of Things: A survey}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1389128610001568},
volume = {54},
year = {2010}
}
@article{Conway1963,
abstract = {A COBOL compiler design is presented which is compact enough to permit rapid, one-pass compilation of a large sub-set of COBOL on a moderately large computer. Versions of the same compiler for smaller machines require only two work-ing tapes plus a compiler tape. The methods given are largely applicable to the construction of ALGOL compilers.},
address = {New York, NY, USA},
author = {Conway, Melvin E},
doi = {10.1145/366663.366704},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Conway - 1963 - Design of a Separable Transition-diagram Compiler.pdf:pdf},
issn = {0001-0782},
journal = {Commun. ACM},
month = {jul},
number = {7},
pages = {396--408},
publisher = {ACM},
title = {{Design of a Separable Transition-diagram Compiler}},
url = {http://melconway.com/Home/pdf/compiler.pdf http://doi.acm.org/10.1145/366663.366704},
volume = {6},
year = {1963}
}
@misc{LLVMProject2018,
author = {{LLVM Project}},
keywords = {C++,LLVM},
mendeley-tags = {C++,LLVM},
title = {{Download LLVM releases}},
url = {http://releases.llvm.org/},
urldate = {2018-08-14},
year = {2018}
}
@inproceedings{Stroustrup1986,
address = {New York, NY, USA},
author = {Stroustrup, Bjarne},
booktitle = {Proceedings of the 1986 SIGPLAN Workshop on Object-oriented Programming},
doi = {10.1145/323779.323736},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Stroustrup - 1986 - An Overview of C.pdf:pdf},
isbn = {0-89791-205-5},
pages = {7--18},
publisher = {ACM},
series = {OOPWORK '86},
title = {{An Overview of C++}},
url = {http://doi.acm.org/10.1145/323779.323736},
year = {1986}
}
@article{Tismer2000,
annote = {http://www.python.org/workshops/2000-01/proceedings.html},
author = {Tismer, C.},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Tismer - 2000 - Continuations and stackless Python.pdf:pdf},
journal = {Proceedings of the 8th International Python Conference},
pages = {2000--01},
title = {{Continuations and stackless Python}},
url = {https://svn.python.org/www/trunk/pydotorg/workshops/2000-01/proceedings/papers/tismers/spcpaper.doc},
year = {2000}
}
@misc{Microsoft2018,
abstract = {This article lists the download links for the latest versions of Microsoft Visual C++.},
author = {{Microsoft Corporation}},
keywords = {C++,MSVC},
mendeley-tags = {C++,MSVC},
title = {{The latest supported Visual C++ downloads}},
url = {https://support.microsoft.com/en-au/help/2977003/the-latest-supported-visual-c-downloads},
urldate = {2018-08-14},
year = {2018}
}
@article{Madsen2017,
author = {Madsen, Magnus and Lhot{\'{a}}k, Ondřej and Tip, Frank},
doi = {10.1145/3133910},
file = {:E$\backslash$:/OneDrive - James Cook University/Mendeley Storage/Madsen, Lhot{\'{a}}k, Tip - 2017 - A model for reasoning about JavaScript promises.pdf:pdf},
issn = {24751421},
journal = {Proceedings of the ACM on Programming Languages},
keywords = {EcmaScript 6,Formal Semantics,JavaScript,Promise Graph,Promises,callback hell},
mendeley-tags = {callback hell},
number = {OOPSLA},
title = {{A model for reasoning about JavaScript promises}},
url = {http://dl.acm.org/citation.cfm?doid=3152284.3133910},
volume = {1},
year = {2017}
}
