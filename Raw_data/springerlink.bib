% Encoding: UTF-8

@InBook{Geilen2010,
  pages     = {967--1006},
  title     = {Kahn Process Networks and a Reactive Extension},
  publisher = {Springer US},
  year      = {2010},
  author    = {Geilen, Marc and Basten, Twan},
  editor    = {Bhattacharyya, Shuvra S. and Deprettere, Ed F. and Leupers, Rainer and Takala, Jarmo},
  address   = {Boston, MA},
  isbn      = {978-1-4419-6345-1},
  abstract  = {Kahn andMacQueen have introduced a generic class of determinate asynchronous data-flow applications, called Kahn Process Networks (KPNs) with an elegant mathematical model and semantics in terms of Scott-continuous functions on data streams together with an implementation model of independent asynchronous sequential programs communicating through FIFO buffers with blocking read and non-blocking write operations. The two are related by the Kahn Principle which states that a realization according to the implementationmodel behaves as predicted by the mathematical function. Additional steps are required to arrive at an actual implementation of a KPN to take care of scheduling of independent processes on a single processor and to manage communication buffers. Because of the expressiveness of the KPN model, buffer sizes and schedules cannot be determined at design time in general and require dynamic run-time system support. Constraints are discussed that need to be placed on such system support so as to maintain the Kahn Principle. We then discuss a possible extension of the KPN model to include the possibility for sporadic, reactive behavior which is not possible in the standard model. The extended model is called Reactive Process Networks. We introduce its semantics, look at analyzability and at more constrained data-flowmodels combined with reactive behavior.},
  booktitle = {Handbook of Signal Processing Systems},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4419-6345-1_34},
  url       = {https://doi.org/10.1007/978-1-4419-6345-1_34},
}

@InBook{Bouillaguet2010,
  pages     = {203--218},
  title     = {Fast Exhaustive Search for Polynomial Systems in {\$}{\{}{\backslash}mathbb{\{}F{\}}{\_}2{\}}{\$}},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Bouillaguet, Charles and Chen, Hsieh-Chung and Cheng, Chen-Mou and Chou, Tung and Niederhagen, Ruben and Shamir, Adi and Yang, Bo-Yin},
  editor    = {Mangard, Stefan and Standaert, Fran{\c{c}}ois-Xavier},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-15031-9},
  abstract  = {We analyze how fast we can solve general systems of multivariate equations of various low degrees over                                                                           {\$}{\{}{\backslash}mathbb{\{}F{\}}{\_}{\{}2{\}}{\}}{\$}                ; this is a well known hard problem which is important both in itself and as part of many types of algebraic cryptanalysis. Compared to the standard exhaustive search technique, our improved approach is more efficient both asymptotically and practically. We implemented several optimized versions of our techniques on CPUs and GPUs. Our technique runs more than 10 times faster on modern graphic cards than on the most powerful CPU available. Today, we can solve 48+ quadratic equations in 48 binary variables on a 500-dollar NVIDIA GTX 295 graphics card in 21 minutes. With this level of performance, solving systems of equations supposed to ensure a security level of 64 bits turns out to be feasible in practice with a modest budget. This is a clear demonstration of the computational power of GPUs in solving many types of combinatorial and cryptanalytic problems.},
  booktitle = {Cryptographic Hardware and Embedded Systems, CHES 2010: 12th International Workshop, Santa Barbara, USA, August 17-20, 2010. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-15031-9_14},
  url       = {https://doi.org/10.1007/978-3-642-15031-9_14},
}

@InBook{Nishimori2012,
  pages     = {119--138},
  title     = {Join Token-Based Event Handling: A Comprehensive Framework for Game Programming},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Nishimori, Taketoshi and Kuno, Yasushi},
  editor    = {Sloane, Anthony and A{\ss}mann, Uwe},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-28830-2},
  abstract  = {In action game programming, programmers have to control multiple concurrent activities on the screen corresponding to multiple game characters. To address this difficulty, many game-oriented scripting languages have been proposed so far. However, current scripting languages seem to lack support for interactions among multiple concurrent activities in a state-dependent manner. To overcome this problem, we propose an event handling framework called ``join token'' in which the states of game characters can be expressed as tokens and interactions can be described as handlers specifying multiple tokens. For the purpose of evaluation, we have developed a game scripting language called ``Mogemoge,'' and wrote several sample games in this language. In this paper, we describe experiences of using join token framework for sample games and compare the code written in Mogemoge against a code written in an existing scripting language.},
  booktitle = {Software Language Engineering: 4th International Conference, SLE 2011, Braga, Portugal, July 3-4, 2011, Revised Selected Papers},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-28830-2_7},
  url       = {https://doi.org/10.1007/978-3-642-28830-2_7},
}

@InBook{Feautrier2014,
  pages     = {113--132},
  title     = {Improving the Performance of X10 Programs by Clock Removal},
  publisher = {Springer Berlin Heidelberg},
  year      = {2014},
  author    = {Feautrier, Paul and Violard, {\'E}ric and Ketterlin, Alain},
  editor    = {Cohen, Albert},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-54807-9},
  abstract  = {X10 is a promising recent parallel language designed specifically to address the challenges of productively programming a wide variety of target platforms. The sequential core of X10 is an object-oriented language in the Java family. This core is augmented by a few parallel constructs that create activities as a generalization of the well known fork/join model. Clocks are a generalization of the familiar barriers. Synchronization on a clock is specified by the Clock.advanceAll() method call. Activities that execute advances stall until all existent activities have done the same, and then are released at the same (logical) time.},
  booktitle = {Compiler Construction: 23rd International Conference, CC 2014, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2014, Grenoble, France, April 5-13, 2014. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-54807-9_7},
  url       = {https://doi.org/10.1007/978-3-642-54807-9_7},
}

@InBook{Amaricai2012,
  pages     = {213--224},
  title     = {Using Cycle-Approximate Simulation for Bus Based Multi-Processor System-On Chip Analysis},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Amaricai, Alexandru and Dobre, Alin and Boncalo, Oana and Tanase, Andrei and Valuch, Camelia},
  editor    = {Precup, Radu-Emil and Kov{\'a}cs, Szilveszter and Preitl, Stefan and Petriu, Emil M.},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-28305-5},
  abstract  = {In this chapter, a cycle approximate simulator for multi-processor system-on chip is presented. The aim of this simulation tool is to enable an enhanced software/hardware analysis capability for bus based systems. The most important contributions are represented by its high flexibility (easy configuration of a SoC using dedicated libraries for generic and specific components and easy integration of other simulators and models), accurate modeling of features specific to multiprocessor systems (busses, inter processor communication mechanisms, etc), accurate implementation of a wide range of performance metrics and power consumption estimates (for processors that support this) and high simulation speed. This way, the proposed simulator can be used for both hardware architecture design exploration and software development.},
  booktitle = {Applied Computational Intelligence in Engineering and Information Technology: Revised and Selected Papers from the 6th IEEE International Symposium on Applied Computational Intelligence and Informatics SACI 2011},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-28305-5_17},
  url       = {https://doi.org/10.1007/978-3-642-28305-5_17},
}

@InBook{Marr√≤n2011,
  pages     = {19--124},
  title     = {State of the Art in Cooperating Objects Research},
  publisher = {Springer Berlin Heidelberg},
  year      = {2011},
  author    = {Marr{\`o}n, Pedro Jos{\'e} and Karnouskos, Stamatis and Minder, Daniel and Ollero, An{\'i}bal},
  editor    = {Marron, Pedro Jos{\'e} and Karnouskos, Stamatis and Minder, Daniel and Ollero, An{\'i}bal},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-16946-5},
  abstract  = {This chapter provides an overview of the State of the Art in Cooperating Object research and, thus, serves as basis for subsequent examinations of the research gaps. Although it tries to give a broad overview of Cooperating Object research it does not cover aspects that seem to be solved from the point of view of academic or industrial research. Having this in mind, we present the State of the Art in hardware, algorithms, non-functional properties, systems and other aspects of Cooperating Objects.},
  booktitle = {The Emerging Domain of Cooperating Objects},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-16946-5_3},
  url       = {https://doi.org/10.1007/978-3-642-16946-5_3},
}

@Article{Hall2008,
  author   = {Hall, Robert J.},
  title    = {A method and tools for large scale scenarios},
  journal  = {Automated Software Engineering},
  year     = {2008},
  volume   = {15},
  number   = {2},
  pages    = {113--148},
  month    = {Jun},
  issn     = {1573-7535},
  abstract = {Formal scenarios have many uses in requirements engineering, validation, performance modeling, and test generation. Many tools and methodologies can handle scenarios when the number of steps (interleaved inputs and outputs of the target system) is reasonably small. However, scenario based techniques do not scale well with the number of steps, number of actors, and complexity of behaviors and system interactions to be specified in the scenario. First, it is impractically tedious and error-prone to specify thousands of input steps and corresponding expected outputs. Second, even if one can write down such large scale scenarios, confidence in their correctness is naturally low. Third, complex systems requiring large scale scenarios tend to require many such scenarios to adequately cover the behavior space. This paper describes the motivations for and problems of large scale scenarios, as well as the LSS method, which uses automated and semi-automated techniques in describing, maintaining, communicating, and using large scale scenarios in requirements engineering. The method is illustrated in two widely divergent application domains: military live training instrumentation and electronic mail servers. A case study demonstrates the practical and beneficial use of LSS in architectural modeling of a complex, real-world system design.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10515-008-0026-8},
  url      = {https://doi.org/10.1007/s10515-008-0026-8},
}

@InBook{Ma2015,
  pages     = {137--143},
  title     = {Implementation of Dijkstra's Token Circulation on Sensor Network},
  publisher = {Springer Berlin Heidelberg},
  year      = {2015},
  author    = {Ma, Zhiqiang and Wang, Achuan and Guo, Jifeng},
  editor    = {Wang, Hongzhi and Qi, Haoliang and Che, Wanxiang and Qiu, Zhaowen and Kong, Leilei and Han, Zhongyuan and Lin, Junyu and Lu, Zeguang},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-662-46248-5},
  abstract  = {Sensor networks can consist of large number of sensors. Often, sensors networks use low cost units and thus a subject to malfunctions that can bring the system to inconsistent states. After deployment, the system can be situated in places that are hard to reach and therefore manual reboot operations are undesirable and even unfeasible. Therefore, it is imperative to consider the eventual recovery of arbitrary fault when designing sensor networks. Dijkstra's algorithm is an important foundation of self-managing computer system and fault-tolerance computing system in distributed systems, since it allows a distributed system to recover from arbitrary starting state within a finite time. The arbitrary starting state ca model arbitrary failure (as long as the code segment stays correct). Another key advantage of Dijkstra's asynchronous algorithm is that no global clock is needed. This project tests an implementation of Dijkstra's algorithm using snapshotting techniques that we developed in an earlier work. These sensors can initiate from any state but they come into a consistent one after several cycles of running. We demonstrate the usefulness of our testing technique.},
  booktitle = {Intelligent Computation in Big Data Era: International Conference of Young Computer Scientists, Engineers and Educators, ICYCSEE 2015, Harbin, China, January 10-12, 2015. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-662-46248-5_17},
  url       = {https://doi.org/10.1007/978-3-662-46248-5_17},
}

@InBook{Costa2009,
  pages     = {245--264},
  title     = {Tuple Space Middleware for Wireless Networks},
  publisher = {Springer Berlin Heidelberg},
  year      = {2009},
  author    = {Costa, Paolo and Mottola, Luca and Murphy, Amy L. and Picco, Gian Pietro},
  editor    = {Garbinato, Beno{\^i}t and Miranda, Hugo and Rodrigues, Lu{\'i}s},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-89707-1},
  abstract  = {Wireless networks define a very challenging scenario for the application programmer. Indeed, the fluidity inherent in the wireless media cannot be entirely masked at the communication layer: issues such as disconnection and a continuously changing execution context most often must be dealt with according to the application logic. Appropriate abstractions, usually provided as part of a middleware, are therefore required to support and simplify the programming task.},
  booktitle = {Middleware for Network Eccentric and Mobile Applications},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-540-89707-1_11},
  url       = {https://doi.org/10.1007/978-3-540-89707-1_11},
}

@InBook{Bierman2012,
  pages     = {233--257},
  title     = {Pause 'n' Play: Formalizing Asynchronous C {\$}^{\backslash}sharp{\$}},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Bierman, Gavin and Russo, Claudio and Mainland, Geoffrey and Meijer, Erik and Torgersen, Mads},
  editor    = {Noble, James},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-31057-7},
  abstract  = {Writing applications that connect to external services and yet remain responsive and resource conscious is a difficult task. With the rise of web programming this has become a common problem. The solution lies in using asynchronous operations that separate issuing a request from waiting for its completion. However, doing so in common object-oriented languages is difficult and error prone. Asynchronous operations rely on callbacks, forcing the programmer to cede control. This inversion of control-flow impedes the use of structured control constructs, the staple of sequential code. In this paper, we describe the language support for asynchronous programming in the upcoming version of C                                                                          {\$}^{\backslash}sharp{\$}                . The feature enables asynchronous programming using structured control constructs. Our main contribution is a precise mathematical description that is abstract (avoiding descriptions of compiler-generated state machines) and yet sufficiently concrete to allow important implementation properties to be identified and proved correct.},
  booktitle = {ECOOP 2012 -- Object-Oriented Programming: 26th European Conference, Beijing, China, June 11-16, 2012. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-31057-7_12},
  url       = {https://doi.org/10.1007/978-3-642-31057-7_12},
}

@InBook{Negele2017,
  pages     = {22--45},
  title     = {On the Design and Implementation of an Efficient Lock-Free Scheduler},
  publisher = {Springer International Publishing},
  year      = {2017},
  author    = {Negele, Florian and Friedrich, Felix and Oh, Suwon and Egger, Bernhard},
  editor    = {Desai, Narayan and Cirne, Walfredo},
  address   = {Cham},
  isbn      = {978-3-319-61756-5},
  abstract  = {Schedulers for symmetric multiprocessing (SMP) machines use sophisticated algorithms to schedule processes onto the available processor cores. Hardware-dependent code and the use of locks to protect shared data structures from simultaneous access lead to poor portability, the difficulty to prove correctness, and a myriad of problems associated with locking such as limiting the available parallelism, deadlocks, starvation, interrupt handling, and so on. In this work we explore what can be achieved in terms of portability and simplicity in an SMP scheduler that achieves similar performance to state-of-the-art schedulers. By strictly limiting ourselves to only lock-free data structures in the scheduler, the problems associated with locking vanish altogether. We show that by employing implicit cooperative scheduling, additional guarantees can be made that allow novel and very efficient implementations of memory-efficient unbounded lock-free queues. Cooperative multitasking has the additional benefit that it provides an extensive hardware independence. It even allows the scheduler to be used as a runtime library for applications running on top of standard operating systems. In a comparison against Windows Server and Linux running on up¬†to 64 cores we analyze the performance of the lock-free scheduler and show that it matches or even outperforms the performance of these two state-of-the-art schedulers in a variety of benchmarks.},
  booktitle = {Job Scheduling Strategies for Parallel Processing: 19th and 20th International Workshops, JSSPP 2015, Hyderabad, India, May 26, 2015 and JSSPP 2016, Chicago, IL, USA, May 27, 2016, Revised Selected Papers},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-61756-5_2},
  url       = {https://doi.org/10.1007/978-3-319-61756-5_2},
}

@InBook{Jungck2011,
  pages     = {205--214},
  title     = {Descriptor Type and Operations},
  publisher = {Apress},
  year      = {2011},
  author    = {Jungck, Peder and Duncan, Ralph and Mulcahy, Dwight},
  address   = {Berkeley, CA},
  isbn      = {978-1-4302-4159-1},
  abstract  = {packetC provides data types that do not appear in standard C but do provide significant support for packet-processing applications. These data types are often extensions of familiar C types. The extended data type described in this chapter is descriptors. This chapter is divided into two different approaches. The first part of this chapter is focused on simply covering examples of descriptors and the packetC standard include file protocols.ph. The second part of this chapter covers an in-depth view into the background of the descriptors and how they operate under the hood as these are new to packetC.},
  booktitle = {packetC Programming},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4302-4159-1_19},
  url       = {https://doi.org/10.1007/978-1-4302-4159-1_19},
}

@InBook{St-Amour2010,
  pages     = {1--17},
  title     = {PICOBIT: A Compact Scheme System for Microcontrollers},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {St-Amour, Vincent and Feeley, Marc},
  editor    = {Moraz{\'a}n, Marco T. and Scholz, Sven-Bodo},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-16478-1},
  abstract  = {Due to their tight memory constraints, small microcontroller based embedded systems have traditionally been implemented using low-level languages. This paper shows that the Scheme programming language can also be used for such applications, with less than 7¬†kB of total memory. We present PICOBIT, a very compact implementation of Scheme suitable for memory constrained embedded systems. To achieve a compact system we have tackled the space issue in three ways: the design of a Scheme compiler generating compact bytecode, a small virtual machine, and an optimizing C compiler suited to the compilation of the virtual machine.},
  booktitle = {Implementation and Application of Functional Languages: 21st International Symposium, IFL 2009, South Orange, NJ, USA, September 23-25, 2009, Revised Selected Papers},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-16478-1_1},
  url       = {https://doi.org/10.1007/978-3-642-16478-1_1},
}

@InBook{Neuendorffer2008,
  pages     = {147--156},
  title     = {Streaming Systems in FPGAs},
  publisher = {Springer Berlin Heidelberg},
  year      = {2008},
  author    = {Neuendorffer, Stephen and Vissers, Kees},
  editor    = {Berekovi{\'{c}}, Mladen and Dimopoulos, Nikitas and Wong, Stephan},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-70550-5},
  abstract  = {As FPGA devices have become larger and more capable, they have transitioned from being used primarily as flexible glue logic to being used as central data processing elements in many digital systems. Typically, these systems (including video processing, wired and wireless networking) rely on streaming architectures. These architectures differ significantly from traditional processor architectures and are able to offer unique challenges and benefits for system designers. In particular, streaming architectures in FPGAs are well suited for implementing upcoming digital convergence applications. We summarize how streaming architectures in FPGAs relate to other programmable platforms for embedded applications and focus on key problem areas related to the design tools and platform infrastructure that will drive these new applications.},
  booktitle = {Embedded Computer Systems: Architectures, Modeling, and Simulation: 8th International Workshop, SAMOS 2008, Samos, Greece, July 21-24, 2008. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-540-70550-5_17},
  url       = {https://doi.org/10.1007/978-3-540-70550-5_17},
}

@Article{Voelter2013,
  author   = {Voelter, Markus and Ratiu, Daniel and Kolb, Bernd and Schaetz, Bernhard},
  title    = {mbeddr: instantiating a language workbench in the embedded software domain},
  journal  = {Automated Software Engineering},
  year     = {2013},
  volume   = {20},
  number   = {3},
  pages    = {339--390},
  month    = {Sep},
  issn     = {1573-7535},
  abstract = {Tools can boost software developer productivity, but building custom tools is prohibitively expensive, especially for small organizations. For example, embedded programmers often have to use low-level C with limited IDE support, and integrated into an off-the-shelf tool chain in an ad-hoc way.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10515-013-0120-4},
  url      = {https://doi.org/10.1007/s10515-013-0120-4},
}

@Article{Ferreira2014,
  author   = {Ferreira, Jo{\~a}o F. and Gherghina, Cristian and He, Guanhua and Qin, Shengchao and Chin, Wei-Ngan},
  title    = {Automated verification of the FreeRTOS scheduler in Hip/Sleek},
  journal  = {International Journal on Software Tools for Technology Transfer},
  year     = {2014},
  volume   = {16},
  number   = {4},
  pages    = {381--397},
  month    = {Aug},
  issn     = {1433-2787},
  abstract = {Automated verification of operating system kernels is a challenging problem, partly due to the use of shared mutable data structures. In this paper, we show how we can automatically verify memory safety and functional correctness properties of the task scheduler component of the FreeRTOS kernel using the verification system Hip/Sleek. We show how some of Hip/Sleek features such as user-defined predicates and lemmas make the specifications highly expressive and the verification process viable. To the best of our knowledge, this is the first code-level verification of memory safety and functional correctness properties of the FreeRTOS scheduler. The outcome of our experiment confirms that Hip/Sleek can indeed be used to verify code that is used in production. Moreover, since the properties that we verify are quite general, we envisage that the same approach can be adopted to verify components of other operating systems.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10009-014-0307-4},
  url      = {https://doi.org/10.1007/s10009-014-0307-4},
}

@InBook{Str√ºbe2010,
  pages     = {63--76},
  title     = {Stateful Mobile Modules for Sensor Networks},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Str{\"u}be, Moritz and Kapitza, R{\"u}diger and Stengel, Klaus and Daum, Michael and Dressler, Falko},
  editor    = {Rajaraman, Rajmohan and Moscibroda, Thomas and Dunkels, Adam and Scaglione, Anna},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-13651-1},
  abstract  = {Most sensor network applications are dominated by the acquisition of sensor values. Due to energy limitations and high energy costs of communication, in-network processing has been proposed as a means to reduce data transfers. As application demands may change over time and nodes run low on energy, get overloaded, or simply face debasing communication capabilities, runtime adaptation is required. In either case, it is useful to be able to migrate computations between neighboring nodes without losing runtime state that might be costly or even impossible to recompute. We propose stateful mobile modules as a basic infrastructure building block to improve adaptiveness and robustness of in-network processing applications. Stateful mobile modules are binary modules linked on the node itself. Even more importantly, they can be transparently migrated from one node to another, thereby keeping statically as well as dynamically allocated memory. This is achieved by an optimized binary format, a memory-efficient linking process and an advanced programming support.},
  booktitle = {Distributed Computing in Sensor Systems: 6th IEEE International Conference, DCOSS 2010, Santa Barbara, CA, USA, June 21-23, 2010. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-13651-1_5},
  url       = {https://doi.org/10.1007/978-3-642-13651-1_5},
}

@InBook{Colnariƒç2008,
  pages     = {107--163},
  title     = {Programming of Embedded Systems},
  publisher = {Springer London},
  year      = {2008},
  address   = {London},
  isbn      = {978-1-84800-052-0},
  abstract  = {Similar to the development in other domains of embedded systems, in practice control applications are often programmed by improper means. For a number of pragmatic reasons, the same methods, techniques, and programming languages as for general-purpose desktop applications are employed. One of the reasons for this is common knowledge of programming: the languages and methods learned can do the job to a certain extent, so most practitioners use them with little concern about the rather specific circumstances of embedded systems},
  booktitle = {Distributed Embedded Control Systems: Improving Dependability with Coherent Design},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-84800-052-0_4},
  url       = {https://doi.org/10.1007/978-1-84800-052-0_4},
}

@Article{Schr√∂der-Preikschat2007,
  author   = {Schr{\"o}der-Preikschat, Wolfgang and Lohmann, Daniel and Scheler, Fabian and Spinczyk, Olaf},
  title    = {Dimensions of variability in embedded operating systems},
  journal  = {Informatik - Forschung und Entwicklung},
  year     = {2007},
  volume   = {22},
  number   = {1},
  pages    = {5--22},
  month    = {Dec},
  issn     = {0949-2925},
  abstract = {Design, implementation, and re-engineering of operating systems are still an ambitious undertaking. Despite, or even because, of the long history of theory and practice in this field, adapting existing systems to environments of different conditions and requirements as originally specified or assumed, in terms of functional and/or non-functional respects, is anything but simple. Especially this is true for the embedded systems domain which, on the one hand, calls for highly specialized and application-aware system abstractions and, on the other hand, cares a¬†great deal for easily reusable implementations of these abstractions. The latter aspect becomes more and more important as embedded systems technology is faced with an innovation cycle decreasing in length. Software for embedded systems needs to be designed for variability, and this is in particular true for the operating systems of this domain. The paper discusses dimensions of variability that need to be considered in the development of embedded operating systems and presents approaches that aid construction and maintenance of evolutionary operating systems.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s00450-007-0037-x},
  url      = {https://doi.org/10.1007/s00450-007-0037-x},
}

@Article{Huang2009,
  author   = {Huang, Kai and Yan, Xiao-lang and Han, Sang-il and Chae, Soo-ik and Jerraya, Ahmed A. and Popovici, Katalin and Guerin, Xavier and Brisolara, Lisane and Carro, Luigi},
  title    = {Gradual refinement for application-specific MPSoC design from Simulink model to RTL implementation},
  journal  = {Journal of Zhejiang University-SCIENCE A},
  year     = {2009},
  volume   = {10},
  number   = {2},
  pages    = {151--164},
  month    = {Feb},
  issn     = {1862-1775},
  abstract = {The application-specific multiprocessor system-on-chip (MPSoC) architecture is becoming an attractive solution to deal with increasingly complex embedded applications, which require both high performance and flexible programmability. As an effective method for MPSoC development, we present a gradual refinement flow starting from a high-level Simulink model to a synthesizable and executable hardware and software specification. The proposed methodology consists of five different abstract levels: Simulink combined algorithm and architecture model (CAAM), virtual architecture (VA), transactional accurate architecture (TA), virtual prototype (VP) and field-programmable gate array (FPGA) emulation. Experimental results of Motion-JPEG and H.264 show that the proposed gradual refinement flow can generate various MPSoC architectures from an original Simulink model, allowing processor, communication and tasks design space exploration.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1631/jzus.A0820085},
  url      = {https://doi.org/10.1631/jzus.A0820085},
}

@InBook{Berry2014,
  pages     = {1--13},
  title     = {Hop and HipHop: Multitier Web Orchestration},
  publisher = {Springer International Publishing},
  year      = {2014},
  author    = {Berry, G{\'e}rard and Serrano, Manuel},
  editor    = {Natarajan, Raja},
  address   = {Cham},
  isbn      = {978-3-319-04483-5},
  abstract  = {Rich applications merge classical computing, client-server concurrency, web-based interfaces, and the complex time- and event-based reactive programming found in embedded systems. To handle them, we extend the Hop web programming platform by HipHop, a domain-specific language dedicated to event-based process orchestration. Borrowing the synchronous reactive model of Esterel, HipHop is based on synchronous concurrency and preemption primitives that are known to be key components for the modular design of complex reactive behaviors. HipHop departs from Esterel by its ability to handle the dynamicity of Web applications, thanks to the reflexivity of Hop. Using a music player example, we show how to modularly build a non-trivial Hop application using HipHop orchestration code.},
  booktitle = {Distributed Computing and Internet Technology: 10th International Conference, ICDCIT 2014, Bhubaneswar, India, February 6-9, 2014. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-04483-5_1},
  url       = {https://doi.org/10.1007/978-3-319-04483-5_1},
}

@Article{Chapman2013,
  author   = {Chapman, Barbara and Eachempati, Deepak and Hernandez, Oscar},
  title    = {Experiences Developing the OpenUH Compiler and Runtime Infrastructure},
  journal  = {International Journal of Parallel Programming},
  year     = {2013},
  volume   = {41},
  number   = {6},
  pages    = {825--854},
  month    = {Dec},
  issn     = {1573-7640},
  abstract = {The OpenUH compiler is a branch of the open source Open64 compiler suite for C, C++, and Fortran 95/2003, with support for a variety of targets including x86{\_}64, IA-64, and IA-32. For the past several years, we have used OpenUH to conduct research in parallel programming models and their implementation, static and dynamic analysis of parallel applications, and compiler integration with external tools. In this paper, we describe the evolution of the OpenUH infrastructure and how we've used it to carry out our research and teaching efforts.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10766-012-0230-9},
  url      = {https://doi.org/10.1007/s10766-012-0230-9},
}

@InBook{Varga2010,
  pages     = {35--59},
  title     = {OMNeT++},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Varga, Andras},
  editor    = {Wehrle, Klaus and G{\"u}ne{\c{s}}, Mesut and Gross, James},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-12331-3},
  abstract  = {OMNeT++ (                                  www.omnetpp.org                                              ) is an extensible, modular, component-based C++ simulation library and framework which also includes an integrated development and a graphical runtime environment. Domain-specific functionality (support for simulation of communication networks, queuing networks, performance evaluation, etc.) is provided by model frameworks, developed as independent projects. There are extensions for real-time simulation, network emulation, support for alternative programming languages (Java, C{\#}), database integration, SystemC integration, HLA and several other functions.},
  booktitle = {Modeling and Tools for Network Simulation},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-12331-3_3},
  url       = {https://doi.org/10.1007/978-3-642-12331-3_3},
}

@InBook{Ierusalimschy2010,
  pages     = {1--12},
  title     = {Programming with Multiple Paradigms in Lua},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Ierusalimschy, Roberto},
  editor    = {Escobar, Santiago},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-11999-6},
  abstract  = {Lua is a scripting language used in many industrial applications, with an emphasis on embedded systems and games. Two key points in the design of the language that led to its widely adoption are flexibility and small size. To achieve these two conflicting goals, the design emphasizes the use of few but powerful mechanisms, such as first-class functions, associative arrays, coroutines, and reflexive capabilities. As a consequence of this design, although Lua is primarily a procedural language, it is frequently used in several different programming paradigms, such as functional, object-oriented, goal-oriented, and concurrent programming, and also for data description.},
  booktitle = {Functional and Constraint Logic Programming: 18th International Workshop, WFLP 2009, Brasilia, Brazil, June 28, 2009, Revised Selected Papers},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-11999-6_1},
  url       = {https://doi.org/10.1007/978-3-642-11999-6_1},
}

@Article{Boers2010,
  author   = {Boers, Nicholas M. and Gburzy{\'{n}}ski, Pawe{\l} and Nikolaidis, Ioanis and Olesi{\'{n}}ski, W{\l}odek},
  title    = {Developing wireless sensor network applications in a virtual environment},
  journal  = {Telecommunication Systems},
  year     = {2010},
  volume   = {45},
  number   = {2},
  pages    = {165--176},
  month    = {Oct},
  issn     = {1572-9451},
  abstract = {We describe our ``holistic'' platform for developing wireless ad hoc sensor networks and focus on its most representative and essential virtualization component: VUE2 (the Virtual Underlay Emulation Engine). Its role is to provide a vehicle for the authoritative emulation of complete networked applications before physically deploying any wireless nodes. The goal is to be able to verify those applications exhaustively before programming the hardware, such that no further (field) tests are necessary. We explain how VUE2 achieves this goal owing to several facilitating factors, most notably the powerful programming paradigm that our platform adopts. As implied by the holistic nature of the discussed system, our work touches upon operating systems, simulation, network protocols, real-time systems, and programming methodology.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s11235-009-9246-x},
  url      = {https://doi.org/10.1007/s11235-009-9246-x},
}

@Article{Sprinkle2011,
  author   = {Sprinkle, Jonathan and Eames, Brandon},
  title    = {Time-triggered buffers for event-based middleware systems},
  journal  = {Innovations in Systems and Software Engineering},
  year     = {2011},
  volume   = {7},
  number   = {1},
  pages    = {9--22},
  month    = {Mar},
  issn     = {1614-5054},
  abstract = {Application developers utilizing event-based middleware have sought to leverage domain-specific modeling for the advantages of intuitive specification, code synthesis, and support for design evolution. For legacy and cyber-physical systems, the use of event-based middleware may mean that changes in computational platform can result anomalous system behavior, due to the presence of implicit temporal dependencies. These anomalies are a function not of the component implementation, but of the model of computation employed for supporting system composition. In order to address these behavioral anomalies, the paper presents an approach where time-based blocks are inserted into the system to account for the temporal dependencies. An advantage of capturing the system composition in a domain-specific modeling language is the ability to efficiently refactor an application to include time-triggered, event-based schedulers. This paper describes how an existing event-based component topology can be modified to permit a time-triggered model of computation, with no changes to the existing component software. Further, the time-triggered components can be deployed alongside standard publish/subscribe methodologies. This strategy is beneficial to the maintenance of existing legacy systems upon upgrade, since the current operational mode could be maintained with minimal changes to the legacy software even under changes to the target platform which alter execution speed. These time-triggered layers are discussed in three permutations: fully triggered, start triggered, and release triggered. A discussion is provided regarding the limitations of each approach, and a brief example is given. The example shows how to apply these triggering approaches without the modification of existing components, but instead through the insertion of triggered buffers between legacy components.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s11334-010-0139-7},
  url      = {https://doi.org/10.1007/s11334-010-0139-7},
}

@InBook{H√∂lzl2016,
  pages     = {201--224},
  title     = {Continuous Collaboration for Changing Environments},
  publisher = {Springer International Publishing},
  year      = {2016},
  author    = {H{\"o}lzl, Matthias and Gabor, Thomas},
  editor    = {Steffen, Bernhard},
  address   = {Cham},
  isbn      = {978-3-319-46508-1},
  abstract  = {Collective autonomic systems (CAS) are distributed collections of agents that collaborate to achieve the system's goals but autonomously adapt their behavior. We present the teacher/student architecture for locally coordinated distributed learning and show that in certain scenarios the performance of a swarm using teacher/student learning can be significantly better than that of agents learning individually. Teacher/student learning serves as foundation for the continuous collaboration (CC) development approach. We introduce CC, relate it to the EDLC, a life cycle model for CAS, and show that CC embodies many of the principles proposed for developing CAS.},
  booktitle = {Transactions on Foundations for Mastering Change I},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-46508-1_11},
  url       = {https://doi.org/10.1007/978-3-319-46508-1_11},
}

@InBook{Ostrowski2010,
  pages     = {452--477},
  title     = {Self-Replicating Objects for Multicore Platforms},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Ostrowski, Krzysztof and Sakoda, Chuck and Birman, Ken},
  editor    = {D'Hondt, Theo},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-14107-2},
  abstract  = {The paper introduces Self-Replicating Objects (SROs), a new concurrent programming abstraction. An SRO is implemented and used much like an ordinary .NET object and can expose arbitrary user-defined APIs, but it is aggressive about automatically exploiting multicore CPUs. It does so by spontaneously and transparently partitioning its state into a set of replicas that handle method calls in parallel and automatically merging replicas before processing calls that cannot execute in the replicated state. Developers need not be concerned about protecting access to shared data; each replica is a monitor and has its own state. The runtime ensures proper synchronization, scheduling, decides when to split/merge, and can transparently migrate replicas to other processes to decrease contention. Compared to threads/locks or toolkits such as .NET Parallel Extensions, SROs offer a simpler, more versatile programming model while delivering comparable, and in some cases even higher performance.},
  booktitle = {ECOOP 2010 -- Object-Oriented Programming: 24th European Conference, Maribor, Slovenia, June 21-25, 2010. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-14107-2_22},
  url       = {https://doi.org/10.1007/978-3-642-14107-2_22},
}

@Article{Kuan2014,
  author   = {Kuan, Chi-Bang and Li, Jia-Jhe and Chen, Chung-Kai and Lee, Jenq-Kuen},
  title    = {C++ Support and Applications for Embedded Multicore DSP Systems},
  journal  = {Journal of Signal Processing Systems},
  year     = {2014},
  volume   = {75},
  number   = {2},
  pages    = {109--122},
  month    = {May},
  issn     = {1939-8115},
  abstract = {In recent years embedded systems have entered the multicore era. As the number of cores keeps growing in embedded systems, it becomes more important to provide programming support which considers embedded system constraints and in the meanwhile helps utilize multicore systems. So far though C still dominates embedded programming, C++ is gaining in importance in parallel programming. It is promising to support C++ for embedded multicore systems. However, embedded systems usually have tight resource budgets, and C++ is commonly considered having huge code size that embedded systems can not afford. Therefore, in this paper we investigate the code size requirement of a C++ library and propose a layered design to provide a code size aware library support. On the other hand, to utilize embedded multicore systems, we employ C++ linguistic features to facilitate embedded multicore programming. With C++, we incorporate high-level abstractions and design patterns into the programming support to enhance low-level programming APIs that can be used to exploit DSPs, SIMD instructions, and DMAs on embedded multicore systems. At last, we evaluate our C++ support with a Blur and a JPEG program. Our result on a dual-DSP platform shows that we can obtain speedups of 3.32 and 3.09 for the Blur and JPEG program, respectively.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s11265-013-0750-6},
  url      = {https://doi.org/10.1007/s11265-013-0750-6},
}

@InBook{Lee2010,
  pages     = {273--287},
  title     = {Disciplined Heterogeneous Modeling},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Lee, Edward A.},
  editor    = {Petriu, Dorina C. and Rouquette, Nicolas and Haugen, {\O}ystein},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-16129-2},
  abstract  = {Complex systems demand diversity in the modeling mechanisms. One way to deal with a diversity of requirements is to create flexible modeling frameworks that can be adapted to cover the field of interest. The downside of this approach is a weakening of the semantics of the modeling frameworks that compromises interoperability, understandability, and analyzability of the models. An alternative approach is to embrace heterogeneity and to provide mechanisms for a diversity of models to interact. This paper reviews an approach that achieves such interaction between diverse models using an abstract semantics, which is a deliberately incomplete semantics that cannot by itself define a useful modeling framework. It instead focuses on the interactions between diverse models, reducing the nature of those interactions to a minimum that achieves a well-defined composition. An example of such an abstract semantics is the actor semantics, which can handle many heterogeneous models that are built today, and some that are not common today. The actor abstract semantics and many concrete semantics have been implemented in Ptolemy II, an open-source software framework distributed under a BSD-style license.},
  booktitle = {Model Driven Engineering Languages and Systems: 13th International Conference, MODELS 2010, Oslo, Norway, October 3-8, 2010, Proceedings, Part II},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-16129-2_20},
  url       = {https://doi.org/10.1007/978-3-642-16129-2_20},
}

@InBook{Parizek2009,
  pages     = {117--132},
  title     = {Platform-Specific Restrictions on Concurrency in Model Checking of Java Programs},
  publisher = {Springer Berlin Heidelberg},
  year      = {2009},
  author    = {Parizek, Pavel and Kalibera, Tomas},
  editor    = {Alpuente, Mar{\'i}a and Cook, Byron and Joubert, Christophe},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-04570-7},
  abstract  = {The main limitation of software model checking is that, due to state explosion, it does not scale to real-world multi-threaded programs. One of the reasons is that current software model checkers adhere to full semantics of programming languages, which are based on very permissive models of concurrency. Current runtime platforms for programs, however, restrict concurrency in various ways --- it is visible especially in the case of critical embedded systems, which typically involve only a single processor and use a threading model based on limited preemption.},
  booktitle = {Formal Methods for Industrial Critical Systems: 14th International Workshop, FMICS 2009, Eindhoven, The Netherlands, November 2-3, 2009. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-04570-7_10},
  url       = {https://doi.org/10.1007/978-3-642-04570-7_10},
}

@InBook{ƒÜulibrk2014,
  pages     = {1--52},
  title     = {Wireless Sensor Network Technology for Precision Agriculture},
  publisher = {Springer New York},
  year      = {2014},
  author    = {{\'{C}}ulibrk, Dubravko and Vukobratovic, Dejan and Minic, Vladan and Fernandez, Marta Alonso and Osuna, Javier Alvarez and Crnojevic, Vladimir},
  address   = {New York, NY},
  isbn      = {978-1-4614-8329-8},
  abstract  = {Precision agriculture demands intensive field data acquisition. One of the keys to understanding productivity variability lays in frequent data acquisition and interpretation. Wireless sensor networks (WSN) are a relatively new and rapidly developing class of wireless communication networks which can provide processed real time field data from sensors distributed in the field. The sensor nodes deployed on the field measure various atmospheric and soil parameters. These measurements can help in making decision on irrigation (automating, semi automating), fertilizer and pesticide applications, intruder detection, pest detection, yield prediction, plant disease prediction, fire detection, etc. The first part of this brief is devoted to Wireless Sensor Network technology with particular focus on its application in precision agriculture.},
  booktitle = {Sensing Technologies For Precision Irrigation},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4614-8329-8_1},
  url       = {https://doi.org/10.1007/978-1-4614-8329-8_1},
}

@Article{Bj√∏rk2013,
  author   = {Bj{\o}rk, Joakim and de Boer, Frank S. and Johnsen, Einar Broch and Schlatte, Rudolf and Tapia Tarifa, S. Lizeth},
  title    = {User-defined schedulers for real-time concurrent objects},
  journal  = {Innovations in Systems and Software Engineering},
  year     = {2013},
  volume   = {9},
  number   = {1},
  pages    = {29--43},
  month    = {Mar},
  issn     = {1614-5054},
  abstract = {Scheduling concerns the allocation of processors to processes, and is traditionally associated with low-level tasks in operating systems and embedded devices. However, modern software applications with soft real-time requirements need to control application-level performance. High-level scheduling control at the application level may complement general purpose OS level scheduling to fine-tune performance of a specific application, by allowing the application to adapt to changes in client traffic on the one hand and to low-level scheduling on the other hand. This paper presents an approach to express and analyze application-specific scheduling decisions during the software design stage. For this purpose, we integrate support for application-level scheduling control in a high-level object-oriented modeling language, Real-Time ABS, in which executable specifications of method calls are given deadlines and real-time computational constraints. In Real-Time ABS, flexible application-specific schedulers may be specified by the user, i.e., developer, at the abstraction level of the high-level modeling language itself and associated with concurrent objects at creation time. Tool support for Real-Time ABS is based on an abstract interpreter that supports simulations and measurements of systems at the design stage.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s11334-012-0184-5},
  url      = {https://doi.org/10.1007/s11334-012-0184-5},
}

@InBook{Ahrens2009,
  pages     = {200--221},
  title     = {The Challenges of Using SDL for the Development of Wireless Sensor Networks},
  publisher = {Springer Berlin Heidelberg},
  year      = {2009},
  author    = {Ahrens, Klaus and Eveslage, Ingmar and Fischer, Joachim and K{\"u}hnlenz, Frank and Weber, Dorian},
  editor    = {Reed, Rick and Bilgic, Attila and Gotzhein, Reinhard},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-04554-7},
  abstract  = {In recent years, Wireless Sensor Networks (WSNs) have been primarily used to build ad-hoc telecommunication infrastructures from scratch or as low-cost alternatives to traditional networks. But the diversity of applications with typically narrow node resources and requirements of already existing information infrastructures sets hard constraints to WSN. The software development process becomes even more complicated when real-time constraints have to be taken into account. This is the case when the physical processes of the WSN environment have to be observed and are realized in space and time. For the development of such WSN we present a model-based framework (GAF4WSN), where the well-known techniques SDL, UML and ASN.1 are involved. The framework was already successfully used for the development of a new generation of Earthquake Early Warning Systems (EEWS). An Earthquake Synthesizer (ES) and an Experiment Management System (EMS) complete the framework, which supports the modelling, simulation, installation and administration of different EEWS approaches in combination with a Geographic Information System (GIS).},
  booktitle = {SDL 2009: Design for Motes and Mobiles: 14th International SDL Forum Bochum, Germany, September 22-24, 2009 Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-04554-7_13},
  url       = {https://doi.org/10.1007/978-3-642-04554-7_13},
}

@InBook{Herdt2016,
  pages     = {177--183},
  title     = {ParCoSS: Efficient Parallelized Compiled Symbolic Simulation},
  publisher = {Springer International Publishing},
  year      = {2016},
  author    = {Herdt, Vladimir and Le, Hoang M. and Gro{\ss}e, Daniel and Drechsler, Rolf},
  editor    = {Chaudhuri, Swarat and Farzan, Azadeh},
  address   = {Cham},
  isbn      = {978-3-319-41540-6},
  abstract  = {We present the tool ParCoSS for verification of cooperative multithreading programs. Our tool is based on the recently proposed Compiled Symbolic Simulation (CSS) technique. Additionally, we employ parallelization to further speed-up the verification. The potential of our tool is shown by evaluation.},
  booktitle = {Computer Aided Verification: 28th International Conference, CAV 2016, Toronto, ON, Canada, July 17-23, 2016, Proceedings, Part II},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-41540-6_10},
  url       = {https://doi.org/10.1007/978-3-319-41540-6_10},
}

@InBook{Lohmann2012,
  pages     = {168--215},
  title     = {The Aspect-Aware Design and Implementation of the CiAO Operating-System Family},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Lohmann, Daniel and Spinczyk, Olaf and Hofer, Wanja and Schr{\"o}der-Preikschat, Wolfgang},
  editor    = {Leavens, Gary T. and Chiba, Shigeru and Haupt, Michael and Ostermann, Klaus and Wohlstadter, Eric},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-35551-6},
  abstract  = {CiAO is the first operating-system family that has been developed with AOP concepts from the very beginning. By its aspect-aware design and implementation, CiAO reaches excellent configurability, separation of concerns, and low footprints in the resulting systems that outperform leading commercial implementations. CiAO implements the automotive operating-system standard OSEK/AUTOSAR OS and provides configurability of all fundamental system properties by means of AOP.},
  booktitle = {Transactions on Aspect-Oriented Software Development IX},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-35551-6_5},
  url       = {https://doi.org/10.1007/978-3-642-35551-6_5},
}

@Article{Paul2013,
  author   = {Paul, Bastien and Marcombes, S{\'e}verin and David, Alexandre and Andreasen Struijk, Lotte N. S. and Le Moullec, Yannick},
  title    = {A Context-Aware User Interface for Wireless Personal-Area Network Assistive Environments},
  journal  = {Wireless Personal Communications},
  year     = {2013},
  volume   = {69},
  number   = {1},
  pages    = {427--447},
  month    = {Mar},
  issn     = {1572-834X},
  abstract = {The daily life of people with severe motor system impairments is challenging and thus often subordinated to extensive external help; increasing their level of self-support is thus highly desirable. Recent advances in wireless communications, in particular in wireless personal-area networks, serve as technological enablers well suited for implementing smart and convenient assistive environments which can increase self-support. This paper presents the design and prototyping of a versatile interface for such wireless assistive environments. We propose a modular framework that can accommodate several wireless personal-area network standards. The interface is built upon this framework and is designed in such a way that it can be controlled by various types of input devices such as a touch screen or a tongue-control unit. The interface can automatically discover consumer appliances (e.g. Zigbee and Bluetooth enabled lights and computers) in the user's environment and display the services supported by these devices on a user-friendly graphical user interface. A demonstrator is prototyped and experimental results show that the proposed interface is context-aware, i.e. it successfully detects available appliances, adapts itself to the changes that occur in the user's environment, and automatically informs the user about these changes. The results also show that the proposed interface is versatile and easy to use, i.e. the user can easily control multiple devices by means of a browser menu. Hence, the proposed work illustrates how assistive technology based on wireless personal-area networks can contribute to improving the quality of life of motor system impaired persons.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s11277-012-0582-x},
  url      = {https://doi.org/10.1007/s11277-012-0582-x},
}

@InBook{Smith2010,
  pages     = {189--248},
  title     = {Game Development with Unity},
  publisher = {Apress},
  year      = {2010},
  author    = {Smith, Ben Britten},
  address   = {Berkeley, CA},
  isbn      = {978-1-4302-2923-0},
  abstract  = {Most of us have built our own game engine in one form or another. If you are a programmer and you build games, then it is like a rite of passage. I have done it. In fact, I have done it a few times. 2D-game engines based on Core Animation, both 2D and 3D engines based on OpenGL and OpenGL ES, the list goes on. I love making my own engines. They do exactly what I need them to do, no more and no less. The downsides: it takes a long time to write your own engine and unless you make the exact same kinds of games over and over again, you will be spending a long time adding features to your engines to match your new game designs. It is often hard to see this happening to yourself because writing game engines is fun!},
  booktitle = {More iPhone Cool Projects: Cool Developers Reveal the Details of Their Cooler Apps and Discuss Their iPad Development Experiences},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4302-2923-0_7},
  url       = {https://doi.org/10.1007/978-1-4302-2923-0_7},
}

@Article{Posse2016,
  author   = {Posse, Ernesto and Dingel, Juergen},
  title    = {An executable formal semantics for UML-RT},
  journal  = {Software {\&} Systems Modeling},
  year     = {2016},
  volume   = {15},
  number   = {1},
  pages    = {179--217},
  month    = {Feb},
  issn     = {1619-1374},
  abstract = {We propose a formal semantics for UML-RT, a UML profile for real-time and embedded systems. The formal semantics is given by mapping UML-RT models into a language called kiltera, a real-time extension of the                                                                           {\$}{\$}{\backslash}pi {\$}{\$}                                                            $\pi$                                                      -calculus. Previous attempts to formalize the semantics of UML-RT have fallen short by considering only a very small subset of the language and providing fundamentally incomplete semantics based on incorrect assumptions, such as a one-to-one correspondence between ``capsules'' and threads. Our semantics is novel in several ways: (1) it deals with both state machine diagrams and capsule diagrams; (2) it deals with aspects of UML-RT that have not been formalized before, such as thread allocation, service provision points, and service access points; (3) it supports an action language; and (4) the translation has been implemented in the form of a transformation from UML-RT models created with IBM's RSA-RTE tool, into kiltera¬†code. To our knowledge, this is the most comprehensive formal semantics for UML-RT to date.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10270-014-0399-z},
  url      = {https://doi.org/10.1007/s10270-014-0399-z},
}

@InBook{Shaver2012,
  pages     = {319--334},
  title     = {The Coroutine Model of Computation},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Shaver, Chris and Lee, Edward A.},
  editor    = {France, Robert B. and Kazmeier, J{\"u}rgen and Breu, Ruth and Atkinson, Colin},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-33666-9},
  abstract  = {This paper presents a general denotational formalism called the Coroutine Model of Computation for control-oriented computational models. This formalism characterizes atomic elements with control behavior as Continuation Actors, giving them a static semantics with a functional interface. Coroutine Models are then defined as networks of Continuation Actors, representing a set of control locations between which control traverses during execution. This paper gives both a strict and non-strict denotational semantics for Coroutine Models in terms of compositions of Continuation Actors and their interfaces. In the strict form, the traversal of control locations forms a control path producing output values, whereas in the non-strict form, execution traverses a tree of potential control locations producing partial information about output values. Furthermore, the given non-strict form of these semantics is claimed to have useful monotonicity properties.},
  booktitle = {Model Driven Engineering Languages and Systems: 15th International Conference, MODELS 2012, Innsbruck, Austria, September 30--October 5, 2012. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-33666-9_21},
  url       = {https://doi.org/10.1007/978-3-642-33666-9_21},
}

@InBook{Kokkonen2015,
  pages     = {254--267},
  title     = {Analysis of Approaches to Internet Traffic Generation for Cyber Security Research and Exercise},
  publisher = {Springer International Publishing},
  year      = {2015},
  author    = {Kokkonen, Tero and H{\"a}m{\"a}l{\"a}inen, Timo and Silokunnas, Marko and Siltanen, Jarmo and Zolotukhin, Mikhail and Neijonen, Mikko},
  editor    = {Balandin, Sergey and Andreev, Sergey and Koucheryavy, Yevgeni},
  address   = {Cham},
  isbn      = {978-3-319-23126-6},
  abstract  = {Because of the severe global security threat of malwares, vulnerabilities and attacks against networked systems cyber-security research, training and exercises are required for achieving cyber resilience of organizations. Especially requirement for organizing cyber security exercises has become more and more relevant for companies or government agencies. Cyber security research, training and exercise require closed Internet like environment and generated Internet traffic. JAMK University of Applied Sciences has built a closed Internet-like network called Realistic Global Cyber Environment (RGCE). The traffic generation software for the RGCE is introduced in this paper. This paper describes different approaches and use cases to Internet traffic generation. Specific software for traffic generation is created, to which no existing traffic generation solutions were suitable.},
  booktitle = {Internet of Things, Smart Spaces, and Next Generation Networks and Systems: 15th International Conference, NEW2AN 2015, and 8th Conference, ruSMART 2015, St. Petersburg, Russia, August 26-28, 2015, Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-23126-6_23},
  url       = {https://doi.org/10.1007/978-3-319-23126-6_23},
}

@InBook{DiSaverio2007,
  pages     = {281--288},
  title     = {Distributed Real-Time Computing with Harness},
  publisher = {Springer Berlin Heidelberg},
  year      = {2007},
  author    = {Di Saverio, Emanuele and Cesati, Marco and Di Biagio, Christian and Pennella, Guido and Engelmann, Christian},
  editor    = {Cappello, Franck and Herault, Thomas and Dongarra, Jack},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-75416-9},
  abstract  = {Modern parallel and distributed computing solutions are often built onto a ``middleware'' software layer providing a higher and common level of service between computational nodes. Harness is an adaptable, plugin-based middleware framework for parallel and distributed computing. This paper reports recent research and development results of using Harness for real-time distributed computing applications in the context of an industrial environment with the needs to perform several safety critical tasks. The presented work exploits the modular architecture of Harness in conjunction with a lightweight threaded implementation to resolve several real-time issues by adding three new Harness plug-ins to provide a prioritized lightweight execution environment, low latency communication facilities, and local timestamped event logging.},
  booktitle = {Recent Advances in Parallel Virtual Machine and Message Passing Interface: 14th European PVM/MPI User's Group Meeting, Paris, France, September 30 - October 3, 2007. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-540-75416-9_39},
  url       = {https://doi.org/10.1007/978-3-540-75416-9_39},
}

@InBook{Jackson2013,
  pages     = {335--347},
  title     = {Formalism and Intuition in Software Engineering},
  publisher = {Springer Berlin Heidelberg},
  year      = {2013},
  author    = {Jackson, Michael},
  editor    = {M{\"u}nch, J{\"u}rgen and Schmid, Klaus},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-37395-4},
  abstract  = {A major and so far unmet challenge in software engineering is to achieve and act upon a clear and sound understanding of the relationship between formalism and intuition in the development process. The challenge is salient in the development of cyber-physical systems, in which the computer interacts with the human and physical world to ensure a behaviour there that satisfies the requirements of the system's stakeholders. The nature of the computer as a formally defined symbol-processing engine invites a formal mathematical approach to software development. Contrary considerations militate against excessive reliance on formalism. The non-formal nature of the human and physical world, the complexity of system function, and the need for human comprehension at every level demand application of non-formal and intuitional knowledge, of insight and technique rather than calculation. The challenge, then, is to determine how these two facets of the development process---formalism and intuition---can work together most productively. This short essay describes some origins and aspects of the challenge and offers a perspective for addressing it.},
  booktitle = {Perspectives on the Future of Software Engineering: Essays in Honor of Dieter Rombach},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-37395-4_20},
  url       = {https://doi.org/10.1007/978-3-642-37395-4_20},
}

@InBook{Grune2012,
  pages     = {313--362},
  title     = {Code Generation},
  publisher = {Springer New York},
  year      = {2012},
  author    = {Grune, Dick and van Reeuwijk, Kees and Bal, Henri E. and Jacobs, Ceriel J. H. and Langendoen, Koen},
  address   = {New York, NY},
  isbn      = {978-1-4614-4699-6},
  abstract  = {We will now turn to the generation of target code from the AST. Although simple code generation is possible, the generation of good code is a field full of snags and snares, and it requires considerable care.We will therefore start with a discussion of the desired properties of generated code.},
  booktitle = {Modern Compiler Design},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4614-4699-6_7},
  url       = {https://doi.org/10.1007/978-1-4614-4699-6_7},
}

@InBook{Lopes2009,
  pages     = {25--41},
  title     = {Programming Wireless Sensor Networks},
  publisher = {Springer Berlin Heidelberg},
  year      = {2009},
  author    = {Lopes, Lu{\'i}s and Martins, Francisco and Barros, Jo{\~a}o},
  editor    = {Garbinato, Beno{\^i}t and Miranda, Hugo and Rodrigues, Lu{\'i}s},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-89707-1},
  abstract  = {Sensor networks can be viewed as a collection of tiny, low-cost devices programmed to sense the physical world and that communicate over radio links [12]. The devices are commonly called motes or smart dust [676], in allusion to their computational and sensing capabilities, as well as their increasingly small size.},
  booktitle = {Middleware for Network Eccentric and Mobile Applications},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-540-89707-1_2},
  url       = {https://doi.org/10.1007/978-3-540-89707-1_2},
}

@InBook{Varghese2015,
  pages     = {1--14},
  title     = {Getting Started with Go},
  publisher = {Apress},
  year      = {2015},
  author    = {Varghese, Shiju},
  address   = {Berkeley, CA},
  isbn      = {978-1-4842-1052-9},
  abstract  = {Everything in this world is evolving, including computers and computer programming languages. Ideas and approaches for building applications are also evolving, based on past experience. Although highly evolved modern computers now have many CPU cores (32, 64, 128 and many more), we still cannot leverage the full power of modern computer hardware by using most of our existing programming languages and tools. Our programs still run slowly, even in high-powered servers with many CPU cores.},
  booktitle = {Web Development with Go: Building Scalable Web Apps and RESTful Services},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4842-1052-9_1},
  url       = {https://doi.org/10.1007/978-1-4842-1052-9_1},
}

@InBook{Wang2012,
  pages     = {381--386},
  title     = {Porting Contiki Operating System to RIEST2430},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Wang, Juan and Ma, Wei and Liu, Dan},
  editor    = {Huang, De-Shuang and Gupta, Phalguni and Zhang, Xiang and Premaratne, Prashan},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-31837-5},
  abstract  = {Based on the analysis of the structure and elements of Contiki embedded real-time operating system, this paper presents the experience with implementing the transplantation of Contiki to the CC2430-based and low-power RIEST2430 platform. Lastly, we test the function of the porting modules. The test results show that all modules work correctly.},
  booktitle = {Emerging Intelligent Computing Technology and Applications: 8th International Conference, ICIC 2012, Huangshan, China, July 25-29, 2012. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-31837-5_55},
  url       = {https://doi.org/10.1007/978-3-642-31837-5_55},
}

@Article{Kriaa2008,
  author   = {Kriaa, Lobna and Bouchhima, Aimen and Gligor, Marius and Fouillart, Anne-Marie and P{\'e}trot, Fr{\'e}deric and Jerraya, Ahmed-Amine},
  title    = {Parallel Programming of Multi-processor SoC: A HW--SW Interface Perspective},
  journal  = {International Journal of Parallel Programming},
  year     = {2008},
  volume   = {36},
  number   = {1},
  pages    = {68--92},
  month    = {Feb},
  issn     = {1573-7640},
  abstract = {For the design of classic computers the parallel programming concept is used to abstract HW/SW interfaces during high level specification of application software. The software is then adapted to existing multiprocessor platforms using a low level software layer that implements the programming model. Unlike classic computers, the design of heterogeneous MPSoC includes also building the processors and other kind of hardware components required to execute the software. In this case, the programming model hides both hardware and software refinements. This paper deals with parallel programming models to abstract both hardware and software interfaces in the case of heterogeneous MPSoC design. Different abstraction levels will be needed. For the long term, the use of higher level programming models will open new vistas for optimization and architecture exploration like CPU/RTOS tradeoffs.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10766-007-0042-5},
  url      = {https://doi.org/10.1007/s10766-007-0042-5},
}

@InBook{Niebert2014,
  pages     = {11--22},
  title     = {Cellular Programming},
  publisher = {Springer International Publishing},
  year      = {2014},
  author    = {Niebert, Peter and Caralp, Mathieu},
  editor    = {Dediu, Adrian-Horia and Lozano, Manuel and Mart{\'i}n-Vide, Carlos},
  address   = {Cham},
  isbn      = {978-3-319-13749-0},
  abstract  = {We present a design approach for ``smart surfaces'' inspired by cellular automata. The aim is to construct and to program scalable distributed realtime interactive systems composed of inexpensive microcontrollers to build surfaces that interact physically with their environment. Our work is both pragmatic and integrated: it covers the entire chain from hardware considerations, a programming model based on a networked locally synchronous virtual machine, dedicated programming language features, a distributed embedded implementation and an integrated programming environment with a simulator implementation of the locally synchronous virtual machine.},
  booktitle = {Theory and Practice of Natural Computing: Third International Conference, TPNC 2014, Granada, Spain, December 9-11, 2014. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-13749-0_2},
  url       = {https://doi.org/10.1007/978-3-319-13749-0_2},
}

@InBook{Nobakht2014,
  pages     = {37--53},
  title     = {Programming with Actors in Java¬†8},
  publisher = {Springer Berlin Heidelberg},
  year      = {2014},
  author    = {Nobakht, Behrooz and de Boer, Frank S.},
  editor    = {Margaria, Tiziana and Steffen, Bernhard},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-662-45231-8},
  abstract  = {There exist numerous languages and frameworks that support an implementation of a variety of actor-based programming models in Java using concurrency utilities and threads. Java¬†8 is released with fundamental new features: lambda expressions and further dynamic invocation support. We show in this paper that such features in Java¬†8 allow for a high-level actor-based methodology for programming distributed systems which supports the programming to interfaces discipline. The embedding of our actor-based Java API is shallow in the sense that it abstracts from the actual thread-based deployment models. We further discuss different concurrent execution and thread-based deployment models and an extension of the API for its actual parallel and distributed implementation. We present briefly the results of a set of experiments which provide evidence of the potential impact of lambda expressions in Java¬†8 regarding the adoption of the actor concurrency model in large-scale distributed applications.},
  booktitle = {Leveraging Applications of Formal Methods, Verification and Validation. Specialized Techniques and Applications: 6th International Symposium, ISoLA 2014, Imperial, Corfu, Greece, October 8-11, 2014, Proceedings, Part II},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-662-45231-8_4},
  url       = {https://doi.org/10.1007/978-3-662-45231-8_4},
}

@InBook{Baudisch2010,
  pages     = {169--180},
  title     = {Dependency-Driven Distribution of Synchronous Programs},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Baudisch, Daniel and Brandt, Jens and Schneider, Klaus},
  editor    = {Hinchey, Mike and Kleinjohann, Bernd and Kleinjohann, Lisa and Lindsay, Peter A. and Rammig, Franz J. and Timmis, Jon and Wolf, Marilyn},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-15234-4},
  abstract  = {In this paper, we describe an automatic synthesis procedure that distributes synchronous programs on a set of desynchronized processing elements. Our distribution procedure consists of three steps: First, we translate the given synchronous program to synchronous guarded actions. Second, we analyze their data dependencies and represent them in a so-called action dependency graph (ADG). Third, the ADG is subsequently partitioned into of sub-graphs where cuts can be made horizontal (for a pipelined execution) or vertical (for a concurrent execution). Finally, we generate for each sub-graph a corresponding component and automatically synthesize a communication infrastructure between these components.},
  booktitle = {Distributed, Parallel and Biologically Inspired Systems: 7th IFIP TC 10 Working Conference, DIPES 2010 and 3rd IFIP TC 10 International Conference, BICC 2010, Held as Part of WCC 2010, Brisbane, Australia, September 20-23, 2010. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-15234-4_17},
  url       = {https://doi.org/10.1007/978-3-642-15234-4_17},
}

@Article{Motika2015,
  author   = {Motika, Christian and von Hanxleden, Reinhard},
  title    = {Light-weight Synchronous Java (SJL): An approach for programming deterministic reactive systems with Java},
  journal  = {Computing},
  year     = {2015},
  volume   = {97},
  number   = {3},
  pages    = {281--307},
  month    = {Mar},
  issn     = {1436-5057},
  abstract = {A key issue in the development of reliable embedded software is the proper handling of reactive control-flow, which typically involves concurrency. Java and its thread concept have only limited provisions for implementing deterministic concurrency. Thus, as has been observed in the past, it is challenging to develop concurrent Java programs without any deadlocks or race conditions. To alleviate this situation, the Light-weight Synchronous Java (SJL) approach presented here adopts the key concepts that have been established in the world of synchronous programming for handling reactive control-flow. Thus SJL not only provides deterministic concurrency, but also different variants of deterministic preemption. Furthermore SJL allows concurrent threads to communicate with Esterel-style signals. As a case study for an embedded system usage, we also report on how the SJL concepts have been ported to the ARM-based Lego Mindstorms NXT system. We evaluated the SJL approach to be efficient and provide experimental results comparing it to Java threads.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s00607-014-0416-7},
  url      = {https://doi.org/10.1007/s00607-014-0416-7},
}

@Article{Maia2012,
  author   = {Maia, Renato and Cerqueira, Renato and de Souza, Clarisse Sieckenius and Guisasola-Gorham, Tom{\'a}s},
  title    = {A qualitative human-centric evaluation of flexibility in middleware implementations},
  journal  = {Empirical Software Engineering},
  year     = {2012},
  volume   = {17},
  number   = {3},
  pages    = {166--199},
  month    = {Jun},
  issn     = {1573-7616},
  abstract = {Today middleware is much more powerful, more reliable and faster than it used to be. Nevertheless, for the application developer, the complexity of using middleware platforms has increased accordingly. The volume and variety of application contexts that current middleware technologies have to support require that developers be able to anticipate the widest possible range of execution environments, desired and undesired effects of different programming strategies, handling procedures for runtime errors, and so on. This paper shows how a generic framework designed to evaluate the usability of notations (the Cognitive Dimensions of Notations Framework, or CDN) has been instantiated and used to analyze the cognitive challenges involved in adapting middleware platforms. This human-centric perspective allowed us to achieve novel results compared to existing middleware evaluation research, typically centered around system performance metrics. The focus of our study is on the process of adapting middleware implementations, rather than in the end product of this activity. Our main contributions are twofold. First, we describe a qualitative CDN-based method to analyze the cognitive effort made by programmers while adapting middleware implementations. And second, we show how two platforms designed for flexibility have been compared, suggesting that certain programming language design features might be particularly helpful for developers.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10664-011-9167-7},
  url      = {https://doi.org/10.1007/s10664-011-9167-7},
}

@InBook{Polishchuk2008,
  pages     = {141--150},
  title     = {Optimal Backlog in the Plane},
  publisher = {Springer Berlin Heidelberg},
  year      = {2008},
  author    = {Polishchuk, Valentin and Suomela, Jukka},
  editor    = {Fekete, S{\'a}ndor P.},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-92862-1},
  abstract  = {Suppose that a cup is installed at every point of a planar set¬†P, and that somebody pours water into the cups. The total rate at which the water flows into the cups is¬†1. A player moves in the plane with unit speed, emptying the cups. At any time, the player sees how much water there is in every cup. The player has no information on how the water will be poured into the cups in the future; in particular, the pouring may depend on the player's motion. The backlog of the player is the maximum amount of water in any cup at any time, and the player's objective is to minimise the backlog. Let D be the diameter of P. If the water is poured at the rate of 1/2 into the cups at the ends of a diameter, the backlog is $\Omega$(D). We show that there is a strategy for the player that guarantees the backlog of O(D), matching the lower bound up to a multiplicative constant. Note that our guarantee is independent of the number of the cups.},
  booktitle = {Algorithmic Aspects of Wireless Sensor Networks: Fourth International Workshop, ALGOSENSORS 2008, Reykjavik, Iceland, July 2008. Revised Selected Papers},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-540-92862-1_12},
  url       = {https://doi.org/10.1007/978-3-540-92862-1_12},
}

@InBook{SenthilBabu2014,
  pages     = {607--615},
  title     = {Energy Model for the Configured MSP430F1612 on a TELOSB Mote with the Help of Contiki},
  publisher = {Springer India},
  year      = {2014},
  author    = {Senthil Babu, K. and Virupaksha, Darshan and Mudgal, Shachi P. and Nagaraja, C.},
  editor    = {Sridhar, V. and Sheshadri, Holalu Seenappa and Padma, M C},
  address   = {New Delhi},
  isbn      = {978-81-322-1157-0},
  abstract  = {Wireless sensor networks (WSN) are attracting a wide range of application because of its exponential growth in its performance. However, there are certain drawbacks with respect to the power available in the node. In this paper, we present a hardware configuration of TelosB mote with the help of Contiki OS which improves the performance of the mote by supporting with additional inbuilt flash memory. The paper includes the energy calculation of the new hardware configured. The existing hardware MSP430F1611 provides 48¬†kB of flash memory which is replaced by MSP430F1612, and Contiki is one such OS which is specifically designed for WSN. In order to provide more flexibility to the application developer, requires of Contiki on a TelosB mote. Contiki support for this modified TELOSB is not available, thereby making an attempt to understand Contiki and port to the modified TELOSB.},
  booktitle = {Emerging Research in Electronics, Computer Science and Technology: Proceedings of International Conference, ICERECT 2012},
  db        = {SpringerLink},
  doi       = {10.1007/978-81-322-1157-0_63},
  url       = {https://doi.org/10.1007/978-81-322-1157-0_63},
}

@InBook{Gong2012,
  pages     = {610--617},
  title     = {Retracted: Modeling and Verifying the Kernel of RTOS},
  publisher = {Springer Berlin Heidelberg},
  year      = {2012},
  author    = {Gong, ShengWen},
  editor    = {Liu, Chunfeng and Wang, Leizhen and Yang, Aimin},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-34038-3},
  abstract  = {This paper presents a study on modeling and verifying the kernel of Real-Time Operating Systems (RTOS). Advances in formally verifying such an RTOS both by refinement and by model checking approaches will be shown in this paper. The focus of the paper will be on verifying FreeRTOS. A number of ways to verify this operating system are investigated in the paper. At last, a preliminary set-up of verifying FreeRTOS using model checking is presented.},
  booktitle = {Information Computing and Applications: Third International Conference, ICICA 2012, Chengde, China, September 14-16, 2012. Proceedings, Part I},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-34038-3_84},
  url       = {https://doi.org/10.1007/978-3-642-34038-3_84},
}

@Article{Han2007,
  author   = {Han, Sang-Il and Chae, Soo-Ik and Brisolara, Lisane and Carro, Luigi and Reis, Ricardo and Gu{\'e}rin, Xavier and Jerraya, Ahmed Amine},
  title    = {Memory-efficient multithreaded code generation from¬†Simulink for heterogeneous MPSoC},
  journal  = {Design Automation for Embedded Systems},
  year     = {2007},
  volume   = {11},
  number   = {4},
  pages    = {249--283},
  month    = {Dec},
  issn     = {1572-8080},
  abstract = {Emerging embedded systems require heterogeneous multiprocessor SoC architectures that can satisfy both high-performance and programmability. However, as the complexity of embedded systems increases, software programming on an increasing number of multiprocessors faces several critical problems, such as multithreaded code generation, heterogeneous architecture adaptation, short design time, and low cost implementation. In this paper, we present a software code generation flow based on Simulink to address these problems. We propose a functional modeling style to capture data-intensive and control-dependent target applications, and a system architecture modeling style to seamlessly transform the functional model into the target architecture. Both models are described using Simulink. From a system architecture Simulink model, a code generator produces a multithreaded code, inserting thread and communication primitives to abstract the heterogeneity of the target architecture. In addition, the multithread code generator called LESCEA applies the extensions of dataflow based memory optimization techniques, considering both data and control dependency. Experimental results on a Motion-JPEG decoder and an H.264 decoder show that the proposed multithread code generator enables easy software programming on different multiprocessor architectures with substantially reduced data memory size (up to¬†68.0{\%}) and code memory size (up to¬†15.9{\%}).},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10617-007-9009-4},
  url      = {https://doi.org/10.1007/s10617-007-9009-4},
}

@InBook{Lilius2010,
  pages     = {7--18},
  title     = {Rialto 2.0: A Language for Heterogeneous Computations},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Lilius, Johan and Dahlin, Andreas and Morel, Lionel},
  editor    = {Hinchey, Mike and Kleinjohann, Bernd and Kleinjohann, Lisa and Lindsay, Peter A. and Rammig, Franz J. and Timmis, Jon and Wolf, Marilyn},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-15234-4},
  abstract  = {Modern embedded systems are often heterogeneous in that their design requires several description paradigms, based on different models of computation and concurrency (MoCCs). In this paper we present Rialto, a formal language intended at expressing computations in several MoCCs. The distinguishing features of Rialto and its implementation are 1) A formal semantics: the language is formalized using SOS (structured operational semantics) rules; 2) Encapsulation of models of computation into policies: we thus distinguish between the syntactic elements of the language (parallelism, interrupts) and its semantics; 3) efficient implementation algorithms. Policies are expressed in the language itself, which allows for more expressive power and a sounder semantics.},
  booktitle = {Distributed, Parallel and Biologically Inspired Systems: 7th IFIP TC 10 Working Conference, DIPES 2010 and 3rd IFIP TC 10 International Conference, BICC 2010, Held as Part of WCC 2010, Brisbane, Australia, September 20-23, 2010. Proceedings},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-15234-4_3},
  url       = {https://doi.org/10.1007/978-3-642-15234-4_3},
}

@InBook{Gabbrielli2010,
  pages     = {413--432},
  title     = {A Short Historical Perspective},
  publisher = {Springer London},
  year      = {2010},
  author    = {Gabbrielli, Maurizio and Martini, Simone},
  address   = {London},
  isbn      = {978-1-84882-914-5},
  abstract  = {Even if the first computers in the modern sense, and therefore the first programming languages, appeared only at the end of the 1940s, since then there have many hundreds (if not thousands) of languages have been defined. In the previous chapters of this book we have sought to identify the most important design and implementation characteristics that are common to large classes of contemporary languages. In this last chapter, we seek to understand what were the reasons that lead, in the last sixty years, to the affirmation of these characteristics and, therefore, to the success of some languages and the disappearance of many others.},
  booktitle = {Programming Languages: Principles and Paradigms},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-84882-914-5_13},
  url       = {https://doi.org/10.1007/978-1-84882-914-5_13},
}

@Article{Stypka2017,
  author   = {Stypka, Jan and Turek, Wojciech and Byrski, Aleksander and Kisiel-Dorohinicki, Marek and Barwell, Adam D. and Brown, Christopher and Hammond, Kevin and Janjic, Vladimir},
  title    = {The Missing Link! A New Skeleton for Evolutionary Multi-agent Systems in Erlang},
  journal  = {International Journal of Parallel Programming},
  year     = {2017},
  month    = {Apr},
  issn     = {1573-7640},
  abstract = {Evolutionary multi-agent systems (EMAS) play a critical role in many artificial intelligence applications that are in use today. In this paper, we present a new generic skeleton in Erlang for parallel EMAS computations. The skeleton enables us to capture a wide variety of concrete evolutionary computations that can exploit the same underlying parallel implementation. We demonstrate the use of our skeleton on two different evolutionary computing applications: (1) computing the minimum of the Rastrigin function; and (2) solving an urban traffic optimisation problem. We show that we can obtain very good speedups (up to 142.44                                                                  {\$}{\$}{\backslash}times {\$}{\$}                                                      {\texttimes}                                                 the sequential performance) on a variety of different parallel hardware, while requiring very little parallelisation effort.},
  day      = {26},
  db       = {SpringerLink},
  doi      = {10.1007/s10766-017-0503-4},
  url      = {https://doi.org/10.1007/s10766-017-0503-4},
}

@Article{Jackson2009,
  author   = {Jackson, Ethan and Sztipanovits, Janos},
  title    = {Formalizing the structural semantics of domain-specific modeling languages},
  journal  = {Software {\&} Systems Modeling},
  year     = {2009},
  volume   = {8},
  number   = {4},
  pages    = {451--478},
  month    = {Sep},
  issn     = {1619-1374},
  abstract = {Model-based approaches to system design are now widespread and successful. These approaches make extensive use of model structure to describe systems using domain-specific abstractions, to specify and implement model transformations, and to analyze structural properties of models. In spite of its general importance the structural semantics of modeling languages are not well-understood. In this paper we develop the formal foundations for the structural semantics of domain-specific modeling languages (DSML), including the mechanisms by which metamodels specify the structural semantics of DSMLs. Additionally, we show how our formalization can complement existing tools, and how it yields algorithms for the analysis of DSMLs and model transformations.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s10270-008-0105-0},
  url      = {https://doi.org/10.1007/s10270-008-0105-0},
}

@InBook{Martorella2014,
  pages     = {121--133},
  title     = {Hardware and Software Platforms for Distributed Computing on Resource Constrained Devices},
  publisher = {Springer International Publishing},
  year      = {2014},
  author    = {Martorella, Gloria and Peri, Daniele and Toscano, Elena},
  editor    = {Gaglio, Salvatore and Lo Re, Giuseppe},
  address   = {Cham},
  isbn      = {978-3-319-03992-3},
  abstract  = {The basic idea of distributed computing is that it is possible to solve a large problem by using the resources of various computing devices connected in a network. Each device interacts with each other in order to process a part of a problem, contributing to the achievement of a global solution. Wireless sensor networks (WSNs) are an example of distributed computing on low resources devices. WSNs encountered a considerable success in many application areas. Due to the constraints related to the small sensor nodes capabilities, distributed computing in WSNs allows to perform complex tasks in a collaborative way, reducing power consumption and increasing battery life. Many hardware platforms compose the ecosystem of WSNs and some lightweight operating systems have also been designed to ease application deployment, to ensure efficient resources management, and to decrease energy consumption. In this chapter we focus on distributed computing from several points of view emphasizing important aspects, ranging from hardware platforms to applications on resource constrained devices.},
  booktitle = {Advances onto the Internet of Things: How Ontologies Make the Internet of Things Meaningful},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-319-03992-3_9},
  url       = {https://doi.org/10.1007/978-3-319-03992-3_9},
}

@Article{Aguado2015,
  author   = {Aguado, Joaqu{\'i}n and Mendler, Michael and von Hanxleden, Reinhard and Fuhrmann, Insa},
  title    = {Denotational fixed-point semantics for constructive scheduling of synchronous concurrency},
  journal  = {Acta Informatica},
  year     = {2015},
  volume   = {52},
  number   = {4},
  pages    = {393--442},
  month    = {Jun},
  issn     = {1432-0525},
  abstract = {The synchronous model of concurrent computation (SMoCC) is well established for programming languages in the domain of safety-critical reactive and embedded systems. Translated into mainstream C/Java programming, the SMoCC corresponds to a cyclic execution model in which concurrent threads are synchronised on a logical clock that cuts system computation into a sequence of macro-steps. A causality analysis verifies the existence of a schedule on memory accesses to ensure each macro-step is deadlock-free and determinate. We introduce an abstract semantic domain                                                                           {\$}{\$}I({\backslash}mathbb {\{}D{\}}, {\backslash}mathbb {\{}P{\}}){\$}{\$}                                                                                    I                        (                        D                        ,                        P                        )                                                                             and an associated denotational fixed-point semantics for reasoning about concurrent and sequential variable accesses within a synchronous cycle-based model of computation. We use this domain for a new and extended behavioural definition of Berry's causality analysis in terms of approximation intervals. The domain                                                                           {\$}{\$}I({\backslash}mathbb {\{}D{\}}, {\backslash}mathbb {\{}P{\}}){\$}{\$}                                                                                    I                        (                        D                        ,                        P                        )                                                                             extends the domain                                                                           {\$}{\$}I({\backslash}mathbb {\{}D{\}}){\$}{\$}                                                                                    I                        (                        D                        )                                                                             from our previous work and fixes a mistake in the treatment of initialisations. Based on this fixed-point semantics we propose the notion of Input Berry-constructiveness (IBC) for synchronous programs. This new IBC class lies properly between strong (SBC) and normal Berry-constructiveness (BC) defined in previous work. SBC and BC are two ways to interpret the standard constructive semantics of synchronous programming, as exemplified by imperative SMoCC languages such as Esterel or Quartz. SBC is often too restrictive as it requires all variables to be initialised by the program. BC can be too permissive because it initialises all variables to a fixed value, by default. Where the initialisation happens through the memory, e.g.,¬†when carrying values from one synchronous tick to the next, then IBC is more appropriate. IBC links two levels of execution, the macro-step level and the micro-step level. We prove that the denotational fixed-point analysis for IBC, and hence Berry's causality analysis, is sound with respect to operational micro-level scheduling. The denotational model can thus be viewed as a compositional presentation of a synchronous scheduling strategy that ensures reactiveness and determinacy for imperative concurrent programming.},
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s00236-015-0238-x},
  url      = {https://doi.org/10.1007/s00236-015-0238-x},
}

@InBook{Martins2014,
  pages     = {244--260},
  title     = {A Web Portal for the Certification of Open Source Software},
  publisher = {Springer Berlin Heidelberg},
  year      = {2014},
  author    = {Martins, Pedro and Fernandes, Jo{\~a}o P. and Saraiva, Jo{\~a}o},
  editor    = {Cerone, Antonio and Persico, Donatella and Fernandes, Sara and Garcia-Perez, Alexeis and Katsaros, Panagiotis and Shaikh, Siraj Ahmed and Stamelos, Ioannis},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-54338-8},
  abstract  = {This paper presents a web portal for the certification of open source software. The portal aims at helping programmers in the internet age, when there are (too) many open source reusable libraries and tools available. Our portal offers programmers a web-based and easy setting to analyze and certify open source software, which is a crucial step to help programmers choosing among many available alternatives, and to get some guarantees before using one piece of software.},
  booktitle = {Information Technology and Open Source: Applications for Education, Innovation, and Sustainability: SEFM 2012 Satellite Events, InSuEdu, MoKMaSD, and OpenCert Thessaloniki, Greece, October 1--2, 2012 Revised Selected Papers},
  db        = {SpringerLink},
  doi       = {10.1007/978-3-642-54338-8_20},
  url       = {https://doi.org/10.1007/978-3-642-54338-8_20},
}

@Article{Grover2017,
  author   = {Grover, Purva and Kar, Arpan Kumar},
  title    = {Big Data Analytics: A Review on Theoretical Contributions and Tools Used in Literature},
  journal  = {Global Journal of Flexible Systems Management},
  year     = {2017},
  volume   = {18},
  number   = {3},
  pages    = {203--229},
  month    = {Sep},
  issn     = {0974-0198},
  abstract = {The importance of data science and big data analytics is growing very fast as organizations are gearing up to leverage their information assets to gain competitive advantage. The flexibility offered through big data analytics empowers functional as well as firm-level performance. In the first phase of the study, we attempt to analyze the research on big data published in high-quality business management journals. The analysis was visualized using tools for big data and text mining to understand the dominant themes and how they are connected. Subsequently, an industry-specific categorization of the studies was done to understand the key use cases. It was found that most of the existing research focuses majorly on consumer discretionary, followed by public administration. Methodologically, a major focus in such exploration is in social media analytics, text mining and machine learning applications for meeting objectives in marketing and supply chain management. However, it was found that not much focus was highlighted in these studies to demonstrate the tools used for the analysis. To address this gap, this study also discusses the evolution, types and usage of big data tools. The brief overview of big data technologies grouped by the services they enable and some of their applications are presented. The study categorizes these tools into big data analysis platforms, databases and data warehouses, programming languages, search tools, and¬†data aggregation and transfer tools. Finally, based on the review, future directions for exploration in big data has been provided for academic and practice.              },
  day      = {01},
  db       = {SpringerLink},
  doi      = {10.1007/s40171-017-0159-3},
  url      = {https://doi.org/10.1007/s40171-017-0159-3},
}

@InBook{Grune2012,
  pages     = {463--507},
  title     = {Explicit and Implicit Memory Management},
  publisher = {Springer New York},
  year      = {2012},
  author    = {Grune, Dick and van Reeuwijk, Kees and Bal, Henri E. and Jacobs, Ceriel J. H. and Langendoen, Koen},
  address   = {New York, NY},
  isbn      = {978-1-4614-4699-6},
  abstract  = {All compilers and many run-time systems use dynamically sized data. The size of such data is not known in advance and room for it must be found at run time. Examples inside the compiler are symbol tables, strings from the source program, ASTs, register interference graphs for graph coloring, and many others. The examples in run-time systems derive from the nature of the source language: strings, dynamically sized arrays in imperative languages, closures in functional languages, tentative unifications in logic languages, and incoming messages in distributed languages are a few that come to mind.},
  booktitle = {Modern Compiler Design},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4614-4699-6_10},
  url       = {https://doi.org/10.1007/978-1-4614-4699-6_10},
}

@InBook{Vajda2011,
  pages     = {153--173},
  title     = {Introduction to Programming Models},
  publisher = {Springer US},
  year      = {2011},
  author    = {Vajda, Andr{\'a}s},
  address   = {Boston, MA},
  isbn      = {978-1-4419-9739-5},
  abstract  = {In this chapter we introduce the foundations for the programming models we consider most suitable for programming many-core chips: communicating sequential processes (CSP), the Actor model and the task based model. For each of these, we shortly survey and compare the most commonly available programming language implementations: the goal is to lay the groundwork for the more in-depth analysis and presentation in the next chapter. An important part of the chapter will deal with the comparative analysis of thread/process based and task based parallelism, as well as an analysis of shared memory based models.},
  booktitle = {Programming Many-Core Chips},
  db        = {SpringerLink},
  doi       = {10.1007/978-1-4419-9739-5_8},
  url       = {https://doi.org/10.1007/978-1-4419-9739-5_8},
}

@Comment{jabref-meta: databaseType:bibtex;}
