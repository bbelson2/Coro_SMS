@INPROCEEDINGS{4417219, 
author={Jiri Zdenek}, 
booktitle={2007 European Conference on Power Electronics and Applications}, 
title={Efficient scheduler-dispatcher software architecture of the spacepower facility distributed control computer}, 
year={2007}, 
pages={1-10}, 
abstract={The system software architecture of the distributed control computer (computer network) of the mechatronic scientific facility (crystallizer) for automatic high temperature material processing in a orbital space station in micro-gravitation environment is presented in this paper. The scientific facility consists of the multi-zone high temperature furnace with heating system, PWM controlled heating converters, the precise extra low speed vibration-less electric drives to make possible to manipulate the processed material samples during experiments, very precise temperature measurement module, telemetric channel, crew interface computer, free programmable central controller and several further units. Facility computer network nodes have many user tasks (processes) divided into many threads running in real time environment. Using preemptive real time operating system tends to have unacceptable high overhead therefore the system of table driven coroutines with low system resource requirement (overhead, stack space) was designed. Emphasis is given on the design of efficient, reliable and self documented scheduler-dispatcher of the user tasks with minimized overhead and easily extensible descriptors of table driven user finite state automata. Presented scheduler architecture is used in the distributed network control computer of newly designed facility (Advanced TITUS) intended to be placed in the ISS space station. It is advanced version of the proved software utilized in the distributed control computer of the TITUS scientific equipment which was successfully operated several years in the MIR orbital station especially during ESA missions EUROMIR.}, 
keywords={aerospace computing;aerospace control;aerospace instrumentation;computer networks;crystallisers;distributed control;electric furnaces;finite state machines;mechatronics;PWM controlled heating converters;TITUS scientific equipment;automatic high temperature material processing;crew interface computer;crystallizer;distributed control computer;distributed network control computer;facility computer network nodes;finite state automata;free programmable central controller;heating system;high temperature furnace;mechatronic scientific facility;microgravitation environment;orbital space station;real time operating system;scheduler-dispatcher software architecture;space power facility;telemetric channel;temperature measurement module;vibrationless electric drives;Automatic control;Centralized control;Computer architecture;Computer networks;Distributed computing;Distributed control;Processor scheduling;Resistance heating;Software architecture;Space stations;Measurement;Mechatronics;Real time processing;Software;Space}, 
doi={10.1109/EPE.2007.4417219}, 
month={Sept},}
@INPROCEEDINGS{5558636, 
author={S. Andalam and P. Roop and A. Girault}, 
booktitle={Eighth ACM/IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE 2010)}, 
title={Predictable multithreading of embedded applications using PRET-C}, 
year={2010}, 
pages={159-168}, 
abstract={We propose a new language called Precision Timed C (PRET-C), for predictable and lightweight multi-threading in C. PRET-C supports synchronous concurrency, preemption, and a high-level construct for logical time. In contrast to existing synchronous languages, PRET-C offers C-based shared memory communications between concurrent threads that is guaranteed to be thread safe. Due to the proposed synchronous semantics, the mapping of logical time to physical time can be achieved much more easily than with plain C, thanks to a Worst Case Reaction Time (WCRT) analyzer (not presented here). Associated to the PRET-C programming language, we present a dedicated target architecture, called ARPRET, which combines a hardware accelerator associated to an existing softcore processor. This allows us to improve the throughput while preserving the predictability. With extensive benchmarking, we then demonstrate that ARPRET not only achieves completely predictable execution of PRET-C programs, but also improves the throughput when compared to the pure software execution of PRET-C. The PRET-C software approach is also significantly more efficient in comparison to two other light-weight concurrent C variants (namely SC and Protothreads), as well as the well-known Esterel synchronous programming language.}, 
keywords={C language;embedded systems;multi-threading;shared memory systems;ARPRET;Esterel synchronous programming language;PRET-C programming language;embedded applications;precision timed C;predictable multithreading;shared memory communications;worst case reaction time analyzer;Assembly;Concurrent computing;Hardware;Instruction sets;Semantics;Timing}, 
doi={10.1109/MEMCOD.2010.5558636}, 
month={July},}
@INPROCEEDINGS{4542057, 
author={A. Anane and E. M. Aboulhamid and J. Vachon and Y. Savaria}, 
booktitle={2008 IEEE International Symposium on Circuits and Systems}, 
title={Modeling and simulation of complex heterogeneous systems}, 
year={2008}, 
pages={2873-2876}, 
abstract={Given the increasing heterogeneity and complexity of systems being developed, untimed modeling at a system level becomes more and more important for design space exploration and verification, due to its conciseness and speed. After showing inadequacies of SystemC, which is the predominant modeling environment in this area, we propose a paradigm shift from immediate notifications and coroutines in SystemC to Atomic Actions and true parallelism in an extension of Esys.NET. We exploit the introspection and attribute programming to extend the capabilities of the environment and to build the basis for heterogeneous cosimulation. This paper aims to show the main advantages of this paradigm shift, such as (1) the improvement of simulation time by exploiting the capabilities of multicore simulation hosts, (2) the reduction of modeling hazards related to parallelism and resource sharing, and (3) a more efficient design space exploration.}, 
keywords={programming language semantics;software engineering;temporal logic;Esys.NET;SystemC;atomic actions;complex heterogeneous systems;heterogeneous cosimulation;multicore simulation;paradigm shift;resource sharing;space exploration;Collaborative work;Costs;Hazards;Kernel;Libraries;Manufacturing processes;Multicore processing;Productivity;Resource management;Space exploration}, 
doi={10.1109/ISCAS.2008.4542057}, 
ISSN={0271-4302}, 
month={May},}
@INPROCEEDINGS{5456987, 
author={R. S. Khaligh and M. Radetzki}, 
booktitle={2010 Design, Automation Test in Europe Conference Exhibition (DATE 2010)}, 
title={Modeling constructs and kernel for parallel simulation of accuracy adaptive TLMs}, 
year={2010}, 
pages={1183-1188}, 
abstract={We present a set of modeling constructs accompanied by a high performance simulation kernel for accuracy adaptive transaction level models. In contrast to traditional, fixed accuracy TLMs, accuracy of adaptive TLMs can be changed during simulation to the level which is most suitable for a given use case and scenario. Ad-hoc development of adaptive models can result in complex models, and the implementation detail of adaptivity mechanisms can obscure the actual logic of a model. To simplify and enable systematic development of adaptive models, we have identified several mechanisms which are applicable to a wide variety of models. The proposed constructs relieve the modeler from low level implementation details of those mechanisms. We have developed an efficient, light-weight simulation kernel optimized for the proposed constructs, which enables parallel simulation of large models on widely available, low-cost multi-core simulation hosts. The modeling constructs and the kernel have been evaluated using industrial benchmark applications.}, 
keywords={operating system kernels;transaction processing;accuracy adaptive transaction level model;ad-hoc development;adaptive TLM;adaptive models systematic development;adaptivity mechanisms;high performance simulation kernel;light weight simulation kernel;low cost multicore simulation hosts;parallel simulation;Adaptive systems;Computational modeling;Concurrent computing;Context modeling;Discrete event simulation;Embedded system;Kernel;Logic;Natural languages;Performance loss}, 
doi={10.1109/DATE.2010.5456987}, 
ISSN={1530-1591}, 
month={March},}
@INPROCEEDINGS{8016226, 
author={A. Elsts and G. Oikonomou and X. Fafoutis and R. Piechocki}, 
booktitle={2017 Global Internet of Things Summit (GIoTS)}, 
title={Internet of Things for smart homes: Lessons learned from the SPHERE case study}, 
year={2017}, 
pages={1-6}, 
abstract={Building large-scale low-power Internet of Things (IoT) systems remains a challenge, as these systems have to meet the requirements of reliability, robustness, and energy-efficiency while running on resource-restricted microcontrollers without memory protection. In this paper we present the case study of IoT in SPHERE (Sensor Platform for HEalthcare in a Residential Environment), a project with the objective to develop a multipurpose, multi-modal sensor platform for monitoring people's health inside their homes. Atypically for academic projects, in 2017 the SPHERE software is going to be deployed in a 100-home study in volunteer homes, therefore it has to satisfy many real-world requirements. We discuss the requirements for IoT networking in this project, the IoT architecture (built on top of Contiki OS), software engineering challenges and lessons learned, as well as some of the general aspects that still make embedded low-power IoT software development difficult.}, 
keywords={Internet of Things;assisted living;power aware computing;sensors;software engineering;IoT;SPHERE case study;embedded low-power IoT software development;energy-efficiency;large-scale low-power Internet of Things systems;multipurpose multimodal sensor platform;real-world requirements;resource-restricted microcontrollers;sensor platform for healthcare in a residential environment;smart homes;software engineering challenges;volunteer homes;Hardware;IEEE 802.15 Standard;Logic gates;Protocols;Reliability;Servers;Software}, 
doi={10.1109/GIOTS.2017.8016226}, 
month={June},}
@INPROCEEDINGS{5665620, 
author={R. Fritzsche and C. Siemers}, 
booktitle={2010 World Automation Congress}, 
title={Scheduling of time enhanced c (TEC)}, 
year={2010}, 
pages={1-6}, 
abstract={Real-time systems mainly consist of time or event-triggered tasks that must satisfy deadline-constraints and other limitations to the execution time. Scheduling of them is a common problem especially if no operating system can be used because of limited resources like code-size and CPU power. Previous approaches deal with multi-frame models to split tasks into smaller subtask that may be arranged at compile-time in a static way to cope with given deadlines. Handling of non-periodic events and context-switching problems demand a more dynamic scheduling. This paper presents an approach of using manually given information for timing constraints in order to rearrange the code to satisfy the deadlines automatically. The presented design is still able to handle events and to force the given functions to cooperate. Supporting hardware for producing timing-events may further help the system to organize the program-flow.}, 
keywords={dynamic scheduling;multiprogramming;real-time systems;software engineering;CPU power;context switching problem;deadline constraint;dynamic scheduling;event triggered task;multiframe model;nonperiodic event;program flow;real time system;split task;time enhanced C;timing constraint;Context;Switches;application-internal scheduler;forced cooperative design;multi-frame tasks;semi-dynamic scheduling;time-enhanced language}, 
ISSN={2154-4824}, 
month={Sept},}
@INPROCEEDINGS{7336328, 
author={D. Yunge and P. Kindt and M. Balszun and S. Chakraborty}, 
booktitle={2015 IEEE 17th International Conference on High Performance Computing and Communications, 2015 IEEE 7th International Symposium on Cyberspace Safety and Security, and 2015 IEEE 12th International Conference on Embedded Software and Systems}, 
title={Hybrid Apps: Apps for the Internet of Things}, 
year={2015}, 
pages={1175-1180}, 
abstract={Smartphones have become popular mainly because of the large variety of applications they can run. In contrast, most devices in the phone's environment - e.g., household appliances or environmental sensors - are much less flexible because their functionality is hardcoded at the design time. In order to realize the vision of the Internet of Things (IoT), where all devices communicate with each other to realize joint tasks, it is necessary that these devices are able to extend and adapt their functionalities on-the-fly based on their surrounding. To realize smart functionalities for IoT devices, we propose "hybrid Apps", the concept of Smartphone "Apps" applied to small embedded systems. In contrast with current packaged "smart home" solutions, where all appliances have to be changed to their smart counterparts at the same time, hybrid Apps permit an incremental and hence feasible deployment of the IoT vision. In this paper we discuss the challenges and opportunities associated with this approach. We argue code interpretation as a candidate reprogramming method for IoT devices and analyzed its feasibility with real-world measurements of key parameters such as computational and energy overhead. While in general, code interpretation incurs a large energy-overhead, we show that for typical IoT applications executed every few seconds, it is as low as 1%.}, 
keywords={Internet of Things;embedded systems;home computing;smart phones;Internet of Things;IoT applications;IoT devices;candidate reprogramming method;code interpretation;embedded systems;energy-overhead;hybrid apps;packaged smart home solutions;smartphone apps;Hardware;Java;Middleware;Protocols;Random access memory;Temperature sensors;Apps;Code Interpreter;Reprogrammability;Virtual Machines;Wireless Sensor Networks}, 
doi={10.1109/HPCC-CSS-ICESS.2015.292}, 
month={Aug},}
@INPROCEEDINGS{6059016, 
author={R. Inam and J. Mäki-Turja and M. Sjödin and S. M. H. Ashjaei and S. Afshar}, 
booktitle={ETFA2011}, 
title={Support for hierarchical scheduling in FreeRTOS}, 
year={2011}, 
pages={1-10}, 
abstract={This paper presents the implementation of a Hierarchical Scheduling Framework (HSF) on an open source real-time operating system (FreeRTOS) to support the temporal isolation between a number of applications, on a single processor. The goal is to achieve predictable integration and reusability of independently developed components or applications. We present the initial results of the HSF implementation by running it on an AVR 32-bit board EVK1100. The paper addresses the fixed-priority preemptive scheduling at both global and local scheduling levels. It describes the detailed design of HSF with the emphasis of doing minimal changes to the underlying FreeRTOS kernel and keeping its API intact. Finally it provides (and compares) the results for the performance measures of idling and deferrable servers with respect to the overhead of the implementation.}, 
keywords={application program interfaces;object-oriented programming;operating system kernels;public domain software;real-time systems;scheduling;software reusability;API;AVR EVK1100;FreeRTOS kernel;application reusability;fixed-priority preemptive scheduling;global scheduling levels;hierarchical scheduling framework;independently developed component reusability;local scheduling levels;open source real-time operating system;predictable integration;single processor;temporal isolation;Job shop scheduling;Kernel;Processor scheduling;Real time systems;Schedules;Servers;fixed-priority scheduling;hierarchical scheduling framework;real-time systems}, 
doi={10.1109/ETFA.2011.6059016}, 
ISSN={1946-0740}, 
month={Sept},}
@INPROCEEDINGS{7515633, 
author={D. P. B. Renaux and F. Pöttker and C. E. Soares and C. C. Valério}, 
booktitle={2016 IEEE 19th International Symposium on Real-Time Distributed Computing (ISORC)}, 
title={A State-Based Function-Queue Software Architecture for Electric Motor Control}, 
year={2016}, 
pages={229-236}, 
abstract={Increasing demands on functional and temporal requirements for the software in electric motor controllers demand for solutions that are efficient in time and space usage while providing the required functionality. Embedded software for electric motor control must deal with the control itself, and with operation, protection, supervision, safety, and user interfaces. Concerning this need, an embedded software multitasking architecture that combines the concept of function queues and of state-based code is proposed and compared to a standard implementation based on an RTOS. In the proposed solution, the queue of function pointers is partitioned into several shorter queues each one active in a given state of the system, thus, reducing queue management overhead.}, 
keywords={control engineering computing;embedded systems;machine control;software architecture;RTOS;electric motor control;embedded software multitasking architecture;function pointer queue;queue management;state-based code;state-based function-queue software architecture;user interfaces;Computer architecture;Electric motors;Embedded software;Motor drives;Multitasking;Real-time systems;Electrical Motor Control;Embedded Software Multitasking Architecture;Real-Time Embedded Software;Task Scheduling}, 
doi={10.1109/ISORC.2016.39}, 
month={May},}
@ARTICLE{5710575, 
author={W. Liu and J. Xu and J. K. Muppala and W. Zhang and X. Wu and Y. Ye}, 
journal={IEEE Embedded Systems Letters}, 
title={Coroutine-Based Synthesis of Efficient Embedded Software From SystemC Models}, 
year={2011}, 
volume={3}, 
number={1}, 
pages={46-49}, 
abstract={SystemC is a widely used electronic system-level (ESL) design language that can be used to model both hardware and software at different stages of system design. There has been a lot of research on behavior synthesis of hardware from SystemC, but relatively little work on synthesizing embedded software for SystemC designs. In this letter, we present an approach to automatic software synthesis from SystemC-based on coroutines instead of the traditional approaches based on real-time operating system (RTOS) threads. Performance evaluation results on some realistic applications show that our approach results in impressive reduction of runtime overheads compared to the thread-based approaches.}, 
keywords={C++ language;embedded systems;operating systems (computers);SystemC models;coroutine-based synthesis;electronic system-level design language;embedded software synthesis;real-time operating system threads;Context;Instruction sets;Kernel;Prototypes;Switches;Synchronization;Performance;SystemC;software synthesis}, 
doi={10.1109/LES.2011.2112634}, 
ISSN={1943-0663}, 
month={March},}
@INPROCEEDINGS{6007780, 
author={S. P. Crago and D. I. Kang and M. Kang and R. Kost and K. Singh and J. Suh and J. P. Walters}, 
booktitle={2011 IEEE Fourth International Conference on Space Mission Challenges for Information Technology}, 
title={Programming Models and Development Software for a Space-Based Many-Core Processor}, 
year={2011}, 
pages={95-102}, 
abstract={The Maestro processor is a 49-core many-core processor for space based on the TILE64 architecture and implemented in rad-hard-by-design technology by Boeing. In this paper we discuss the programming models for Maestro, the implications of the programming model on fault tolerance and flight software, and the software development tools that have been developed for Maestro. The software described here is experimental development software that allows application and algorithm evaluation on the architecture, but we believe this software can be used as the basis for flight software. The software includes libraries, performance analysis and optimization tools, and compilers. While this work was done on the Maestro chip, the principles discussed can be applied to any multi-core or many-core processor.}, 
keywords={aerospace computing;computer architecture;microprocessor chips;multiprocessing systems;program compilers;program processors;software architecture;software fault tolerance;software libraries;software performance evaluation;49-core manycore processor;Maestro chip;Maestro processor;TILE64 architecture;fault tolerance;flight software;multicore processor;optimization tool;programming model;rad-hard-by-design technology;software compiler;software development tool;software library;space-based manycore processor;Computer architecture;Libraries;Linux;Message passing;Programming;Real time systems;Software;Multi-core programming;parallel software;space-based processing}, 
doi={10.1109/SMC-IT.2011.29}, 
month={Aug},}
@INPROCEEDINGS{7363616, 
author={S. Park and H. Kim and S. Y. Kang and C. H. Koo and H. Joe}, 
booktitle={2015 IEEE 13th International Conference on Embedded and Ubiquitous Computing}, 
title={Lua-Based Virtual Machine Platform for Spacecraft On-Board Control Software}, 
year={2015}, 
pages={44-51}, 
abstract={Mission critical embedded software for autonomous operation requires high development cost due to its long development cycle. One of the potential solutions for reducing the cost is to reuse the software developed at previous missions. Virtual machine platform such as JVM is a good example to provide code portability across various missions. Flight software in aerospace field is adopting this concept to improve reusability and eventually to reduce development cost. In this paper, we propose a Lua-based virtualization environment for spacecraft flight software. Flight software for spacecraft control consists of a few tasks that are highly autonomous. Lua is chosen as the script language for programming the control tasks. Though Lua was designed with simplicity and portability, it only supports multithreading with collaborative coroutines. To support preemptive multitasking, we implement time slicing coroutines as spacecraft control processes. New coroutine scheduler is devised and time slicing functionality is added into the scheduler. Scheduler locking and message passing with external flight software are also implemented. Instead of modifying the Lua interpreter, we have exploited the debug support APIs for our implementation. For evaluation, we have implemented the flight software virtualization environment on the flight computer. Accuracy of the time slicing scheduler is also analyzed.}, 
keywords={aerospace control;application program interfaces;authoring languages;control engineering computing;message passing;multi-threading;program debugging;scheduling;software portability;software reusability;space vehicles;spacecraft computers;virtual machines;virtualisation;JVM;Lua interpreter;Lua script language;Lua-based virtual machine platform;Lua-based virtualization environment;aerospace field;autonomous operation;code portability;collaborative coroutines;control task programming;coroutine scheduler;debug support API;development cost reduction;flight computer;flight software virtualization environment;highly autonomous task;message passing;mission critical embedded software;multithreading;preemptive multitasking;scheduler locking;software reuse;spacecraft control;spacecraft flight software;spacecraft on-board control software;time slicing coroutines;time slicing scheduler;Computers;Engines;Runtime;Software;Space vehicles;Virtual machining;Virtualization;Lua;OBCP;mission critical embedded software;reusability;spacecraft;virtual machine}, 
doi={10.1109/EUC.2015.21}, 
month={Oct},}
@INPROCEEDINGS{7383583, 
author={Z. Cheng and Y. Li and R. West}, 
booktitle={2015 IEEE Real-Time Systems Symposium}, 
title={Qduino: A Multithreaded Arduino System for Embedded Computing}, 
year={2015}, 
pages={261-272}, 
abstract={Arduino is an open source platform that offers a clear and simple environment for physical computing. It is now widely used in modern robotics and Internet of Things (IoT) applications, due in part to its low-cost, ease of programming, and rapid prototyping capabilities. Sensors and actuators can easily be connected to the analog and digital I/O pins of an Arduino device, which features an on-board microcontroller programmed using the Arduino API. The increasing complexity of physical computing applications has now led to a series of Arduino-compatible devices with faster processors, increased flash storage, larger memories and more complicated I/O architectures. The Intel Galileo, for example, is designed to support the Arduino API on top of a Linux system, code-named Clanton. However, the standard API is restricted to the capabilities found on less powerful devices, lacking support for multithreaded programs, or specification of real-time requirements. In this paper, we present Qduino, a system developed for Arduino compatible boards. Qduino provides an extended Arduino API which, while backward-compatible with the original API, supports real-time multithreaded sketches and event handling. Experiments show the performance gains of Qduino compared to Clanton Linux.}, 
keywords={Linux;application program interfaces;formal specification;multi-threading;public domain software;real-time systems;Arduino API;Arduino compatible boards;Arduino-compatible devices;Clanton;I/O architectures;Intel Galileo;Internet of Things applications;IoT applications;Linux system;Qduino;Quest real-time operating system;actuators;backward-compatibility;embedded computing;event handling;flash storage;multithreaded Arduino system;multithreaded programs;on-board microcontroller;open source platform;physical computing applications;programming;rapid prototyping capabilities;real-time multithreaded sketches;real-time requirement specification;robotics;sensors;Computer architecture;Hardware;Instruction sets;Kernel;Linux;Real-time systems;Standards;Arduino;embedded systems;multi-threading;real-time}, 
doi={10.1109/RTSS.2015.32}, 
ISSN={1052-8725}, 
month={Dec},}
@ARTICLE{6463378, 
author={S. Andalam and P. S. Roop and A. Girault and C. Traulsen}, 
journal={IEEE Transactions on Computers}, 
title={A Predictable Framework for Safety-Critical Embedded Systems}, 
year={2014}, 
volume={63}, 
number={7}, 
pages={1600-1612}, 
abstract={Safety-critical embedded systems, commonly found in automotive, space, and health-care, are highly reactive and concurrent. Their most important characteristics are that they require both functional and timing correctness. C has been the language of choice for programming such systems. However, C lacks many features that can make the design process of such systems seamless while also maintaining predictability. This paper addresses the need for a C-based design framework for achieving time predictability. To this end, we propose the PRET-C language and the ARPRET architecture. PRET-C offers a small set of extensions to a subset of C to facilitate effective concurrent programming. We present a new synchronous semantics for PRET-C. It guarantees that all PRET-C programs are deterministic, reactive, and provides thread-safe communication via shared memory access. This simplifies considerably the design of safety-critical systems. We also present the architecture of a precision timed machine (PRET) called ARPRET. It offers the ability to design time predictable architectures through simple customizations of soft-core processors. We have designed ARPRET particularly for efficient and predictable execution of PRET-C. We demonstrate through extensive benchmarking that PRET-C based system design excels in comparison to existing C-based paradigms. We also qualitatively compare our approach to the Berkeley-Columbia PRET approach. We have demonstrated that the proposed approach provides an ideal framework for designing and validating safety-critical embedded systems.}, 
keywords={C language;embedded systems;multi-threading;programming language semantics;safety-critical software;shared memory systems;ARPRET;ARPRET architecture;Berkeley-Columbia PRET approach;C-based design framework;PRET-C language;PRET-C programs;Precision Timed C language;architecture of a precision timed machine;concurrent programming;deterministic programs;lightweight multithreaded language;reactive programs;safety-critical embedded systems;shared memory access;soft-core processors;synchronous semantics;thread-safe communication;time predictable architectures;Computer architecture;Instruction sets;Programming;Real-time systems;Semantics;Timing;PRET;PRET-C;Safety-critical systems;WCET;WCRT;synchronous languages;time predictability}, 
doi={10.1109/TC.2013.28}, 
ISSN={0018-9340}, 
month={July},}
@INPROCEEDINGS{4624024, 
author={D. G. Kim and S. M. Lee and D. R. Shin}, 
booktitle={2008 Fourth International Conference on Networked Computing and Advanced Information Management}, 
title={Design of the Operating System Virtualization on L4 Microkernel}, 
year={2008}, 
volume={1}, 
pages={307-310}, 
abstract={The importance of the virtualization in embedded computing area is currently emerging. The virtualization can enhance system flexibility by enabling the concurrent execution of an application OS and a real-time OS (RTOS) on the same processor. L4 microkernel can be used as an efficient hypervisor which provides environment for operating systems virtualization. In order to run the application OSes on L4 microkernel, the application OSes should be adapted. The source code of Linux kernel can be readily accessed and modified. Hence, the Linux kernel is chosen as virtualized operating systems. In this paper, the architecture for virtualization of Linux kernel which is based on L4 microkernel is proposed.}, 
keywords={Linux;operating system kernels;virtual machines;L4 microkernel;Linux kernel virtualization;concurrent execution;embedded computing;hypervisor;operating system virtualization;real-time operating system;system flexibility;Application software;Application virtualization;Embedded computing;Kernel;Linux;Operating systems;Platform virtualization;Real time systems;Virtual machine monitors;Yarn}, 
doi={10.1109/NCM.2008.165}, 
month={Sept},}
@ARTICLE{7387670, 
author={M. Amjad and M. Sharif and M. K. Afzal and S. W. Kim}, 
journal={IEEE Sensors Journal}, 
title={TinyOS-New Trends, Comparative Views, and Supported Sensing Applications: A Review}, 
year={2016}, 
volume={16}, 
number={9}, 
pages={2865-2889}, 
abstract={The wireless sensor network (WSN) is an interesting area for modern day research groups. Tiny sensor nodes are deployed in a diversity of environments but with limited resources. Scarce resources compel researchers to employ an operating system that requires limited memory and minimum power. Tiny operating system (TinyOS) is a widely used operating system for sensor nodes, which provides concurrency and flexibility while adhering to the constraints of scarce resources. Comparatively, TinyOS is considered to be the most robust, innovative, energy-efficient, and widely used operating system in sensor networks. This paper looks at the state-of-the-art TinyOS and the different dimensions of its design paradigm, programming model, execution model, scheduling algorithms, concurrency, memory management, hardware support platforms, and other features. The addition of different features in TinyOS makes it the operating system of choice for WSNs. Sensing nodes with TinyOS seem to show more flexibility in supporting diverse types of sensing applications.}, 
keywords={systems software;wireless sensor networks;Tiny operating system;concurrency;design paradigm;execution model;hardware support platforms;memory management;programming model;scheduling algorithms;sensor nodes;wireless sensor network;Adaptation models;Concurrent computing;Instruction sets;Operating systems;Programming;Sensors;Wireless sensor networks;Wireless sensor networks;energy efficiency;operating system;sensor nodes},
doi={10.1109/JSEN.2016.2519924}, 
ISSN={1530-437X}, 
month={May},}
@INPROCEEDINGS{5272418, 
author={E. Lubbers and M. Platzner}, 
booktitle={2009 International Conference on Field Programmable Logic and Applications}, 
title={Cooperative multithreading in dynamically reconfigurable systems}, 
year={2009}, 
pages={551-554}, 
abstract={Preemptive multitasking, a popular technique for timesharing of computational resources in software-based systems, faces considerable difficulties when applied to partially reconfigurable hardware. In this paper, we propose a cooperative scheduling technique for reconfigurable hardware threads as a feasible compromise between computational efficiency and implementation complexity. We have implemented this mechanism for the multithreaded reconfigurable operating system ReconOS and evaluated its overheads and performance on a prototype.}, 
keywords={multi-threading;multiprogramming;operating systems (computers);reconfigurable architectures;scheduling;ReconOS;cooperative multithreading;cooperative scheduling technique;dynamically reconfigurable system;multithreaded reconfigurable operating system;preemptive multitasking;Delay;Field programmable gate arrays;Hardware;Multitasking;Multithreading;Operating systems;Processor scheduling;Prototypes;Reconfigurable logic;Yarn}, 
doi={10.1109/FPL.2009.5272418}, 
ISSN={1946-147X}, 
month={Aug},}