% Encoding: UTF-8

@Article{Saeedloei:2016:MMV:2930957.2930963,
  author     = {Saeedloei, Neda and Gupta, Gopal},
  title      = {A Methodology for Modeling and Verification of Cyber-physical Systems Based on Logic Programming},
  journal    = {SIGBED Rev.},
  year       = {2016},
  volume     = {13},
  number     = {2},
  pages      = {34--42},
  month      = apr,
  issn       = {1551-3688},
  abstract   = {Model-based design and development has been applied successfully to design and development of complex systems, including safety critical systems. It is also a promising approach for designing cyber-physical systems (CPSs). In this paper we propose a methodology for model-based design of CPSs where, logic programming extended with coinduction, constraints over reals, and coroutining is used for modeling CPSs. This logic programming realization can be used for verifying interesting properties as well as generating implementations of CPSs. We use the reactor temperature control system as a running example to illustrate the various steps of our methodology. We present a model of the system using our framework and verify the safety property of the system. We also show how parametric analysis can be performed in our framework.},
  acmid      = {2930963},
  address    = {New York, NY, USA},
  db         = {ACM},
  doi        = {10.1145/2930957.2930963},
  issue_date = {April 2016},
  numpages   = {9},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/2930957.2930963},
}

@Article{Saeedloei:2011:LMV:2000367.2000374,
  author     = {Saeedloei, Neda and Gupta, Gopal},
  title      = {A Logic-based Modeling and Verification of CPS},
  journal    = {SIGBED Rev.},
  year       = {2011},
  volume     = {8},
  number     = {2},
  pages      = {31--34},
  month      = jun,
  issn       = {1551-3688},
  abstract   = {Cyber-physical systems (CPS) consist of perpetually and concurrently executing physical and computational components. The presence of physical components require the computational components to deal with continuous quantities. A formalism that can model discrete and continuous quantities together with concurrent, perpetual execution is lacking. In this paper we report on the development of a formalism based on logic programming extended with co-induction, constraints over reals, and coroutining that allows CPS to be elegantly modeled. This logic programming realization can be used for verifying interesting properties as well as generating implementations of CPS. We illustrate this formalism by applying it to elegant modeling of the reactor temperature control system. Interesting properties of the system can be verified merely by posing appropriate queries to this model. Precise parametric analysis can also be performed.  },
  acmid      = {2000374},
  address    = {New York, NY, USA},
  db         = {ACM},
  doi        = {10.1145/2000367.2000374},
  issue_date = {June 2011},
  numpages   = {4},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/2000367.2000374},
}

@Article{Ali:2011:PPM:2070336.2070350,
  author     = {Ali, Hazem Ismail and Pinho, Lu\'{\i}s Miguel},
  title      = {A Parallel Programming Model for Ada},
  journal    = {Ada Lett.},
  year       = {2011},
  volume     = {31},
  number     = {3},
  pages      = {19--26},
  month      = nov,
  issn       = {1094-3641},
  abstract   = {Over the last three decades, computer architects have been able to achieve an increase in performance for single processors by, e.g., increasing clock speed, introducing cache memories and using instruction level parallelism. However, because of power consumption and heat dissipation constraints, this trend is going to cease. In recent times, hardware engineers have instead moved to new chip architectures with multiple processor cores on a single chip. With multi-core processors, applications can complete more total work than with one core alone. To take advantage of multi-core processors, parallel programming models are proposed as promising solutions for more effectively using multi-core processors. This paper discusses some of the existent models and frameworks for parallel programming, leading to outline a draft parallel programming model for Ada.  },
  acmid      = {2070350},
  address    = {New York, NY, USA},
  db         = {ACM},
  doi        = {10.1145/2070336.2070350},
  issue_date = {December 2011},
  keywords   = {ada, lightweight threads model, many-core systems, parallel programming},
  numpages   = {8},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/2070336.2070350},
}

@InProceedings{Ali:2011:PPM:2070337.2070350,
  author    = {Ali, Hazem Ismail and Pinho, Lu\'{\i}s Miguel},
  title     = {A Parallel Programming Model for Ada},
  booktitle = {Proceedings of the 2011 ACM Annual International Conference on Special Interest Group on the Ada Programming Language},
  year      = {2011},
  series    = {SIGAda '11},
  pages     = {19--26},
  address   = {New York, NY, USA},
  publisher = {ACM},
  abstract  = {Over the last three decades, computer architects have been able to achieve an increase in performance for single processors by, e.g., increasing clock speed, introducing cache memories and using instruction level parallelism. However, because of power consumption and heat dissipation constraints, this trend is going to cease. In recent times, hardware engineers have instead moved to new chip architectures with multiple processor cores on a single chip. With multi-core processors, applications can complete more total work than with one core alone. To take advantage of multi-core processors, parallel programming models are proposed as promising solutions for more effectively using multi-core processors. This paper discusses some of the existent models and frameworks for parallel programming, leading to outline a draft parallel programming model for Ada.  },
  acmid     = {2070350},
  db        = {ACM},
  doi       = {10.1145/2070337.2070350},
  isbn      = {978-1-4503-1028-4},
  keywords  = {ada, lightweight threads model, many-core systems, parallel programming},
  location  = {Denver, Colorado, USA},
  numpages  = {8},
  url       = {http://doi.acm.org/10.1145/2070337.2070350},
}

@Article{Schimpf:2012:MPE:2379703.2379738,
  author     = {Schimpf, Paul H.},
  title      = {Modified Protothreads for Embedded Systems},
  journal    = {J. Comput. Sci. Coll.},
  year       = {2012},
  volume     = {28},
  number     = {1},
  pages      = {177--184},
  month      = oct,
  issn       = {1937-4771},
  abstract   = {Protothreads are stackless lightweight threads that provide a mechanism for concurrent programming with very low overhead in any environment that supports an ANSI-C compiler. No processor-specific task switching code is required to implement them. In their published form they are not quite adequate for a priority-based based scheduler and thus are of questionable utility in an embedded system with real-time requirements. This article discusses the protothread library along with modifications and an example priority-based scheduler that may be of some utility in embedded systems environments lacking an RTOS. },
  acmid      = {2379738},
  address    = {USA},
  db         = {ACM},
  issue_date = {October 2012},
  numpages   = {8},
  publisher  = {Consortium for Computing Sciences in Colleges},
  url        = {http://dl.acm.org/citation.cfm?id=2379703.2379738},
}

@Article{Kumar:2007:ESI:1210268.1210270,
  author     = {Kumar, Nagendra J. and Asokan, Vasanth and Shivshankar, Siddhartha and Dean, Alexander G.},
  title      = {Efficient Software Implementation of Embedded Communication Protocol Controllers Using Asynchronous Software Thread Integration with Time- and Space-efficient Procedure Calls},
  journal    = {ACM Trans. Embed. Comput. Syst.},
  year       = {2007},
  volume     = {6},
  number     = {1},
  month      = feb,
  issn       = {1539-9087},
  abstract   = {The overhead of context switching limits efficient scheduling of multiple concurrent threads on a uniprocessor when real-time requirements exist. A software-implemented protocol controller may be crippled by this problem. The available idle time may be too short to recover through context switching, so only the primary thread can execute during message activity, slowing the secondary threads and potentially missing deadlines. Asynchronous software thread integration (ASTI) uses coroutine calls and integration, letting threads make independent progress efficiently, and reducing the needed context switches. We demonstrate the methods with a software implementation of an automotive communication protocol (J1850) and several secondary threads.},
  acmid      = {1210270},
  address    = {New York, NY, USA},
  articleno  = {2},
  db         = {ACM},
  doi        = {10.1145/1210268.1210270},
  issue_date = {February 2007},
  keywords   = {Asynchronous software thread integration, J1850, fine-grain concurrency, hardware to software migration, software-implemented communication protocol controllers},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/1210268.1210270},
}

@InProceedings{vonHanxleden:2009:SCP:1629335.1629366,
  author    = {von Hanxleden, Reinhard},
  title     = {SyncCharts in C: A Proposal for Light-weight, Deterministic Concurrency},
  booktitle = {Proceedings of the Seventh ACM International Conference on Embedded Software},
  year      = {2009},
  series    = {EMSOFT '09},
  pages     = {225--234},
  address   = {New York, NY, USA},
  publisher = {ACM},
  abstract  = {SyncCharts in C (SC) extends C with control flow operators for deterministic, light-weight concurrency and preemption. SC is based on SyncCharts, a synchronous variant of Statecharts with a sound formal basis. SC implements concurrency via a simulation of multi-threading, inspired by reactive processing. This approach permits very fast context switches and allows to express SC operators with regular, sequential C code. Thus a concurrent SC program requires neither a special compiler nor OS support for concurrency.  A reference implementation of SC, based on C macros, is available as open source code. SC can be used in a number of scenarios: 1) as a regular programming language, requiring just a C compiler; 2) as an intermediate target language for synthesizing graphical SyncChart models into executable code, in a traceable manner; 3) as instruction set architecture for programming precision timed (PRET) or reactive architectures, abstracting functionality from physical timing; or 4) as a virtual machine instruction set, with a very dense encoding.},
  acmid     = {1629366},
  db        = {ACM},
  doi       = {10.1145/1629335.1629366},
  isbn      = {978-1-60558-627-4},
  keywords  = {SyncCharts, esterel, model-based design, multi-threading, reactive processing, statecharts, synchronous programming},
  location  = {Grenoble, France},
  numpages  = {10},
  url       = {http://doi.acm.org/10.1145/1629335.1629366},
}

@InProceedings{Jahier:2016:RRP:2906363.2906372,
  author    = {Jahier, Erwan},
  title     = {RDBG: A Reactive Programs Extensible Debugger},
  booktitle = {Proceedings of the 19th International Workshop on Software and Compilers for Embedded Systems},
  year      = {2016},
  series    = {SCOPES '16},
  pages     = {116--125},
  address   = {New York, NY, USA},
  publisher = {ACM},
  abstract  = {Debugging reactive programs requires to provide a lot of inputs -- at each reaction step. Moreover, because a reactive system reacts to an environment it tries to control, providing realistic inputs can be hard. The same considerations apply for automatic testing. This work take advantage on previous work on automated testing of reactive programs that close this feedback loop.  This article demonstrates how to implement opportunistically such a debugging commands interpreter by taking advantage of an existing (ocaml) toplevel Read-Eval-Print Loop (REPL). Then it shows how a small kernel is enough to build a full-featured debugger with little effort. The given examples provide a tutorial for end-users that wish to write their own debugging primitives, fitting to their needs, or to tune existing ones.  An orthogonal contribution of this article is to present an efficient way to implement the debugger coroutining using continuations.  The Reactive programs DeBuGger (RDBG) prototype aims at being versatile and general enough to be able to deal with any reactive languages. We have experimented it on 2 synchronous programming: Lustre and Lutin.},
  acmid     = {2906372},
  db        = {ACM},
  doi       = {10.1145/2906363.2906372},
  isbn      = {978-1-4503-4320-6},
  keywords  = {Code Instrumentation, Compiler, Continuations, Dynamic Analysis, Interpreter, Monitor, Programmable Debuggers, Reactive systems, Synchronous languages},
  location  = {Sankt Goar, Germany},
  numpages  = {10},
  url       = {http://doi.acm.org/10.1145/2906363.2906372},
}

@InProceedings{Hannig:2011:RPS:1988932.1988941,
  author    = {Hannig, Frank and Roloff, Sascha and Snelting, Gregor and Teich, J\"{u}rgen and Zwinkau, Andreas},
  title     = {Resource-aware Programming and Simulation of MPSoC Architectures Through Extension of X10},
  booktitle = {Proceedings of the 14th International Workshop on Software and Compilers for Embedded Systems},
  year      = {2011},
  series    = {SCOPES '11},
  pages     = {48--55},
  address   = {New York, NY, USA},
  publisher = {ACM},
  abstract  = {The efficient use of future MPSoCs with 1000 or more processor cores requires new means of resource-aware programming to deal with increasing imperfections such as process variation, fault rates, aging effects, and power as well as thermal problems. In this paper, we apply a new approach called invasive computing that enables an application programmer to spread computations to processors deliberately and on purpose at certain points of the program. Such decisions can be made depending on the degree of application parallelism and the state of the underlying resources such as utilization, load, and temperature. The introduced programming constructs for resource-aware programming are embedded into the parallel computing language X10 as developed by IBM using a library-based approach. Moreover, we show how individual heterogeneous MPSoC architectures may be modeled for subsequent functional simulation by defining compute resources such as processors themselves by lightweight threads that are executed in parallel together with the application threads by the X10 run-time system. Thus, the state changes of each hardware resource may be simulated including temperature, aging, and other useful monitor functionality to provide a first high-level programming test-bed for invasive computing.},
  acmid     = {1988941},
  db        = {ACM},
  doi       = {10.1145/1988932.1988941},
  isbn      = {978-1-4503-0763-5},
  keywords  = {MPSoC, X10, resource-aware programming, simulation},
  location  = {St. Goar, Germany},
  numpages  = {8},
  url       = {http://doi.acm.org/10.1145/1988932.1988941},
}

@Comment{jabref-meta: databaseType:bibtex;}
